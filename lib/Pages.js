
// Generated by Page Builder
import Page from './Page';
import _    from 'lodash';

export default {

    $pages() {
        return Object.values(this).filter(page => page instanceof Page);
    },

    $blogs() {
        return this.$pages().filter(page => page.blog).sort(Page.compareDates);
    },

    $search(searchText) {
        const regex   = new RegExp(_.escapeRegExp(_.escape(searchText)), 'i');
        const results = [];
        for (const page of this.$pages()) {
            if (page.$searchRegex(regex)) {
                results.push(page);
            }
        }
        return results;
    },

    about: new Page({
        name: 'about',
        content: 'I am Eric Buss. I am a developer, designer, and soon to be Software Engineer. I have a love for programming language design, functional programming, open source projects, and horror movies.\n\n# Skills\nA list of the technologies I am familiar with. Related subskills are \nlisted in \\[brackets\\].\n\n> JavaScript \\[TypeScript React CoffeeScript Express\\] / HTML \\[Jade/Pug\\] /\n> CSS \\[Sass Less Bootstrap\\] / Python \\[Matplotlib Numpy Pandas SciPy TensorFlow\\] / \n> C \\[C++ Objective-C iOS AVR ARM OpenGL\\] / Java \\[Clojure\\] / \n> PHP \\[CodeIgniter\\] / Databases \\[SQL MongoDB\\] / R / Git / MATLAB / \n> OS-familiarity \\[`icon:fab fa-windows` `icon:fab fa-apple` Ubuntu openSUSE Fedora\\]\n\nFor more information feel free to [contact me](mailto:root@ejrbuss.net) or look at my [resume](/static/rsc/resume.pdf).\n\n# Testimonials\nSome nice people have had nice things to say about my work!\n\n> *“Thanks Eric for leading the \\[...\\] prototype. You have set a strong foundation for the coming \\[...\\] WebApp. The beauty is that, with you and John, I had no worries we would had come up with the right solution. It is also a big thank you for being that thorough on code quality which also has been a big part of \\[the app\'s\\] success.”*\n>\n> **— Gino Lord (Former Supervisor)**\n>\n> *“Thanks for excellent work on the \\[App\\] features”*\n>\n> **— Aroosh Elahi (Former Supervisor)** \n>\n> *“Incredibly talented! Introduced style guidelines and function blocks so our app won’t be too ugly inside. Good job on your \\[...\\] prototype!"* \n> \n> **— John Peng (Former Fellow Coop)**\n>\n> *“Unreasonably hardworking. Terribly good at what they do”*\n> \n> **— David Choi (Former Fellow Coop)**\n\n# Contact\n\nroot@ejrbuss.net',
        plainTxt: 'I am Eric Buss. I am a developer, designer, and soon to be Software Engineer. I have a love for programming language design, functional programming, open source projects, and horror movies.\nSkills\nA list of the technologies I am familiar with. Related subskills are \nlisted in [brackets].\nJavaScript [TypeScript React CoffeeScript Express] / HTML [Jade/Pug] /\nCSS [Sass Less Bootstrap] / Python [Matplotlib Numpy Pandas SciPy TensorFlow] / \nC [C++ Objective-C iOS AVR ARM OpenGL] / Java [Clojure] / \nPHP [CodeIgniter] / Databases [SQL MongoDB] / R / Git / MATLAB / \nOS-familiarity [icon:fab fa-windows icon:fab fa-apple Ubuntu openSUSE Fedora]\n\nFor more information feel free to contact me or look at my resume.\nTestimonials\nSome nice people have had nice things to say about my work!\n“Thanks Eric for leading the [...] prototype. You have set a strong foundation for the coming [...] WebApp. The beauty is that, with you and John, I had no worries we would had come up with the right solution. It is also a big thank you for being that thorough on code quality which also has been a big part of [the app&#39;s] success.”\n— Gino Lord (Former Supervisor)\n“Thanks for excellent work on the [App] features”\n— Aroosh Elahi (Former Supervisor) \n“Incredibly talented! Introduced style guidelines and function blocks so our app won’t be too ugly inside. Good job on your [...] prototype!&quot; \n— John Peng (Former Fellow Coop)\n“Unreasonably hardworking. Terribly good at what they do”\n— David Choi (Former Fellow Coop)\n\nContact\nroot@ejrbuss.net\n',
        route: '/about',
        layout: '../layouts/About',
        title: 'About',
    }),
    blog: new Page({
        name: 'blog',
        content: '',
        plainTxt: '',
        route: '/blog',
        layout: '../layouts/Archive',
        title: 'Blog Archive',
    }),
    github: new Page({
        name: 'github',
        content: '',
        plainTxt: '',
        route: '/blog/github',
        layout: '../../layouts/Blog',
        title: 'GitHub Catalog',
        subtitle: 'A trip down memory lane. I catalog all of my GitHub repositories, both finished projects, and those that never got off the ground.',
        blog: true,
        date: '05-15-2019',
    }),
    rtos1: new Page({
        name: 'rtos1',
        content: '> # Author\'s Note\n>\n> *This blog post is part one in a series originally put together for the University of Victoria\'s CSC 460 course. The original content was publishd February 6 2019 by [Torrey Randolph](https://github.com/torreyr) and myself. As that webpage no longer exists I am now hosting the content here.*\n>\n> *Here are links to [part 2](/blog/rtos2) and [part 3](/blog/rtos3).*\n\n# Introduction\n\nThe goal of project 1 was to familiarize ourselves with the hardware and software interfaces we would be using throughout the semester. This project was broken in to two phases, details of which are provided below. This introductory section breaks down the software, hardware, and shared design decisions that were used to complete project 1.\n\nIn phase 1 we integrate these elements into a working solution. We control and aim a laser using an analog stick and detect the laser using a photocell. In phase 2 we create a similar solution, only this time we split the components across two boards and connect them together over Bluetooth.\n\n## Software Dependencies\n\nWe took advantage of the software ecosystem provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\n\n - [VS Code](https://code.visualstudio.com/): We opted to move away from Arduino IDE to a more developed code editor after completing exercises 1 through 5. Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\n - [AVR Toolchain](https://www.nongnu.org/avr-libc/): In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR micro-controllers. AVR Libc is the backbone of the Arduino libraries. We included the source code of relevant Arduino libraries with our projects for ease of integration with hardware. These libraries include [ArduinoCore-avr](https://github.com/arduino/ArduinoCore-avr), [Servo](https://github.com/arduino-libraries/Servo), and [LiquidCrystal](https://github.com/arduino-libraries/LiquidCrystal). The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\n - [Mekpie](https://ejrbuss.net/mekpie/): Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \n - [Saleae Logic](https://www.saleae.com/): This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\n\n## Hardware\n\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\n - [2x Arduino Mega 2560 boards](https://store.arduino.cc/usa/arduino-mega-2560-rev3): Only one of these was needed in phase 1, but phase 2 required the creation of a base and remote station.\n - [2x SG-90 Micro Servos](http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf) in a pan and tilt module: These two servos are used to aim a mounted KY-008 Laser.\n - [2x HC-06 Bluetooth modules](http://wiki.sunfounder.cc/index.php?title=Bluetooth_Transceiver_Module_HC-06): These two Bluetooth modules are used to communicate between the base and remote stations in phase 2.\n - [Arduino LCD KeyPad Shield](https://www.dfrobot.com/wiki/index.php/Arduino_LCD_KeyPad_Shield_(SKU:_DFR0009)): The Liquid Crystal Display is used to display relevant information, such as the current X and Y values of the analog stick.\n - [Arduino KY-023 Joystick](https://tkkrlab.nl/wiki/Arduino_KY-023_XY-axis_joystick_module): An analog joystick used to control the motion of the pan and tilt module.\n - [KY-008 Laser](http://henrysbench.capnfatz.com/henrys-bench/arduino-output-devices/ky-008-arduino-laser-module-guide-and-tutorial/): This laser is used to shoot at our photocell. \n - [photocell](https://learn.adafruit.com/photocells): Used to detect the laser.\n\n## Fixed Point Operations\n\nThe AVR processor does not have built in support for floating point types. As a consequence, floating point operations are achieved using software. This has the drawback that performing floating point arithmetic is significantly slower than integer arithmetic, transforming 1-cycle instructions into 200 plus cycle instructions. This had a noticeable performance impact during exercise 4 when contrasting floating point analysis of an analog signal to integer analysis. When considering performance and our overarching goal of achieving low power consumption, it is in our interest to have as few floating point operations in our solution as possible.\n\nWhen considering how to approach calculations typically done with floating point types, such as a low pass filter, we decided that fixed point operation may fit our needs.\n\nFixed point types can be considered integer values that are scaled up and down to represent smaller values. For instance, a fixed point scale of 10 would mean that 15 represents 1.5, and 57 represents 5.7. For efficient transformation to and from a fixed point format embedded programmers typically use a scale that is a power of 2. This allows scaling to be done by bit shifting. Fixed point numbers used in this way are typically expressed in the form QI.F where Q is the "sign" bit (in the 2\'s complement sense), I is the integer bits, and F is the fractional bits. So our chosen fixed point format of Q7.8 translates to a 16-bit value of the form:\n\n```math\nSign bit → 0 Integer bits → 0000000 Fractional bits → 00000000\n```\n\nThe implementation of the data type is quite straightforward. Q7.8 corresponds to a scale of 0x0100.\n\n```lang:c-readonly\n// [-128.996, 127.996]\n#define Q78_SCALE_FACTOR 0x0100\n\n// Q7.8\ntypedef s16 Q78_t;\n\n#define Q78(n) ((Q78_t) ((n) * Q78_SCALE_FACTOR))\n```\n\nWe provide a type definition and a conversion macro for convenience.  A macro is used rather than a function to allow for optimization of numeric constants. If a fixed point number is immediately added to or subtracted from a numeric constant and it is initialized using a macro, the numeric constants can be pre-applied by the compiler.\n\nFixed point numbers have several advantages, the first being that addition and subtraction are trivial. Integer addition and subtraction of fixed point values sharing the same scale work without additional effort. Multiplication and division requires a little more work, but not much. \n\n```lang:c-readonly\nQ78_t Q78_mul(Q78_t a, Q78_t b) {\n    s32 tmp_a = a;\n    s32 tmp_b = b;\n    s32 tmp_c = (tmp_a * tmp_b) / Q78_SCALE_FACTOR;\n    return (Q78_t) tmp_c;\n}\n\nQ78_t Q78_div(Q78_t a, Q78_t b) {\n    s32 tmp_a = a;\n    s32 tmp_b = b;\n    s32 tmp_c = (tmp_a * Q78_SCALE_FACTOR) / tmp_b;\n    return (Q78_t) tmp_c;\n}\n\nQ78_t Q78_lpf(Q78_t sample, Q78_t average, Q78_t factor) {\n    static Q78_t one = Q78(1);\n    return Q78_mul(sample, factor) + Q78_mul(average, (one - factor));\n}\n```\n\nThe key to these operations is ensuring that you do not overflow your intermediate values, hence both multiplication and division use 32-bit integers for intermediate values. In addition to multiplication and division operations, we also implement a simple low pass filter using fixed point values.\n\nThe core drawback of fixed point numbers is their limited range. For Q7.8 we can represent values between -128.996 and 127.996. This means that wherever we take advantage of fixed point numbers in our project we must ensure that our operands and results fit within that range.\n\nThe implementation of fixed point discussed here is based off a series of [online lectures on the topic by Eli Hughes](https://www.youtube.com/watch?v=bbFBgXndmP0). Fixed point numbers are just one solution in a sea of possible ways of representing and computing the results of fractional arithmetic. We also looked into rational number formats, but ultimately preferred fixed point representations because of their simplicity.\n\n# Phase 1\n\n## Overview\n\nThe goal of phase 1 was to use an analog stick to control and aim a laser to shoot a photocell that could subsequently detect the shot. All of these components were integrated using a single Arduino board. Thanks to the five exercises completed prior to phase 1. producing our solution was a smooth process. The block diagram below shows the general setup of our system.\n\n![phase 1 block diagram](/static/blog/rtos1/phase-1-block.jpg)\n\nA 10kΩ resistor was used to create a voltage divider for our photocell. As the resistance of the photocell changes when light is shone on it, the voltage across the 10kΩ resistor changes. That voltage is reported by the Mega 2560, mapped to the range (0, 1023). When the photocell is hit by the laser, the voltage reported increases to above a certain threshold, which was determined by trial and error.\n\n![phase 1 voltage divider](/static/blog/rtos1/voltage-divider.jpg)\n\nPhase 1 featured a simple main loop where we sample the analog stick, adjust the servos, toggle the laser, and then check if our photocell has been hit. There are no delays in this process so we simply try to go through these steps as quickly as possible, and then repeat. This is a poor solution when considering power consumption, as the CPU is never idle. It is important that the LCD is only updated when the photocell actually changes state. We discovered this in an earlier implementation where updating the LCD on every iteration of our main loop resulted in an unintelligible output from the LCD.\n\n```lang:c-readonly\nfor (;;) {\n    map_servo_pan(sample_stick_u_x(), 0, STICK_U_OFFSET_X);\n    map_servo_tilt(-sample_stick_u_y(), 0, STICK_U_OFFSET_Y);\n    if (stick_u_down()) {\n        set_laser(ON);\n    } else {\n        set_laser(OFF);\n    }\n    if (photocell_hit()) {\n        lcd.clear();\n        lcd.print("Hit :O");\n        set_laser(OFF);\n        break;\n    }\n}\n```\n\nOur sampling method for the analog sticks was established during exercise 4. We use a combination of a low pass filter and a clamp. For efficient computing, these computations are performed using fixed point values. After reading the raw analog value, we scale it down so that it will fit within the fixed point range, and then offset it so that the values are centred at 0. This makes more efficient use of the signed fixed point range.\n\nAfter reading, scaling, and offsetting our value we pass it through a simple low pass filter. The low pass filter is implemented as a simple rolling average function. Passing the value through the low pass filter reduces noise and gets us smoother feeling control with the stick. We pass all values into the low pass filter, including those that fall into the dead zone. This increases the accuracy of our rolling average.\n\nThe previously mentioned dead zone is a small region around the zero signal of the stick, that is clamped down to 0. This clamping combats two issues with analog inputs. The first is that the sticks have some noise in their input signal, even when at rest. This means that the measured value can be greater or less than 0 even if no one is touching the stick. Additionally, the sticks do not always come to rest at the exact same position due to friction, wear, and manufacturing imperfections. A dead zone mitigates these issues.\n\nOur dead zone is implemented using a clamp. We similarly clamp the maximum value slightly below the theoretical maximum. This ensures that when you push the stick to the furthest edge in any direction we return the same maximum value.\n\nPutting all of these decisions together we end up with the following implementation.\n\n```lang:c-readonly\n\nint sample_stick_u_x() {\n    static Q78_t rolling_x = Q78(0);\n    static Q78_t sample_x  = Q78(0);\n    sample_x  = Q78((analogRead(STICK_U_PIN_X) - STICK_U_OFFSET_X) / STICK_SCALE);\n    rolling_x = Q78_lpf(sample_x, rolling_x, STICK_LFP_FACTOR);\n    int x     = Q78_to_int(rolling_x);\n    if (x < 0) {\n        x = clamp(x + STICK_U_DEADZONE, STICK_U_MIN_X, 0);\n    } else if (x > 0) {\n        x = clamp(x - STICK_U_DEADZONE, 0, STICK_U_MAX_X);\n    }\n    return x;\n}\n```\n\nCorrectly performing these operations requires we measure out constants for each analog stick. Namely their minimum, maximum, and resting values. We determined these values using a separate program, and recorded the constants for each of our two sticks. This ensures we are obtaining the highest quality samples possible.\n\nWe map the stick values to the servo positions in an intelligent manner. The servo is moved in discrete steps. These steps enforce a maximum delta in position and a minimum delay between changes. This protects the servo from having its position changed too rapidly, which could damage it.\n\nThe implementation first checks to see if the servos are ready to have their positions changed again; this is done by keeping track of the last time they were called using Arduino\'s millis function. If sufficient time has passed we change the input into a fractional value between 0 and 1 and multiply this by our maximum delta. This means that small changes will map to slow rotation of the servo and large changes will map to fast rotation of the servo. We also clamp the delta again to ensure that we do not exceed our maximum delta due to incorrect arguments. Finally, we clamp the position before writing it to ensure we do not move the servo past its maximum range. Most of these operations are performed with fixed point values for efficiency.\n\n```lang:c-readonly\nvoid map_servo_pan(int value, int min_value, int max_value) {\n    static int servo_pan_position = SERVO_PAN_CENTER;\n    static int last_call = 0;\n    int this_call = millis();\n    if (this_call - last_call < SERVO_PAN_DELAY) {\n        return;\n    }\n    last_call = this_call;\n    Q78_t range = Q78(SERVO_PAN_MAX_SPEED);\n    Q78_t ratio = Q78_div(Q78(value - min_value), Q78(max_value));\n    Q78_t delta = Q78_mul(range, ratio);\n    servo_pan_position += clamp(Q78_to_int(delta), -SERVO_PAN_MAX_SPEED, SERVO_PAN_MAX_SPEED);\n    servo_pan_position =  clamp(servo_pan_position, SERVO_PAN_BOTTOM, SERVO_PAN_TOP);\n    servo_pan.writeMicroseconds(servo_pan_position);\n}\n```\n\n# Phase 2\n\n## Overview\n\nThe goal of phase 2 was to separate the components into two stations, each with a Mega 2560 board and have them communicate over Bluetooth. Below are block diagrams of the two stations.\n\n![phase 2 block diagram 1](/static/blog/rtos1/phase-2-block-1.jpg)\n\n![phase 2 block diagram 2](/static/blog/rtos1/phase-2-block-2.jpg)\n\nThe base station includes the LCD, the joystick, the photocell, and one of the Bluetooth modules connected to a Mega 2560. The remote station consists of the pan and tilt servo motors, the laser, and the other Bluetooth module connected to another Mega 2560. The base station sends the joystick position to the remote station, which updates the servo motors and the laser positions correspondingly. In our implementation, the base station also sends a done flag when the photocell is hit by the laser to indicate that the program should gracefully shut down.\n\n##  Polling and TTA\n\nPhase 2 is to be implemented using a time triggered architecture (TTA). We make use of a [scheduler developed by Neil MacMillan](https://nrqm.ca/mechatronics-lab-guide/lab-guide-time-triggered-scheduling/), a former TA of this course. In a TTA, tasks, implemented here as C functions, are run on a set period. In between these tasks the CPU is simply left to idle. A TTA has a number of benefits to real-time systems.\n\n - They are deterministic; a correct schedule will remain correct ad infinitum.\n - They are simple, especially compared to preemptive schedulers.\n - They are lightweight, as the scheduler itself has very little bookkeeping to accomplish.\n\nThe choice of a TTA led us to the decision of avoiding interrupts in both phase 1 and 2. TTA nicely integrates with polling-based algorithms, so for all our inputs and communication we use polling rather than interrupts to keep up with IO.\n\nIn our implementation the base station and remote station both alternated between two tasks. The base station had the task sample for collecting input from the analog stick and photocell, and send for packaging that information together and sending it over Bluetooth. The remote station had the task receive for collecting the information sent from the base station and control for using that information in the activation of the laser and servo motors. The actual implementation of these tasks rely on the same code presented in phase 1.\n\nWe elected to sample our analog stick at approximately 60Hz. This was done based off the knowledge that responsive video games typically target 60 frames per second. We then match this rate in sending out the input information to the remote station. In retrospect, it would be worth investigating sampling at an even higher rate, and sending at the same or slightly slower rate. The logic being that the low pass filter we apply to our analog stick input would be most effective on an over sampled input.\n\nOn the remote station we faced a number of issues actually receiving a message. We hypothesized that this was due to two core problems:\n\n1. The Bluetooth and/or UART pin on the board had a limited buffer which could overflow and produce unexpected results.\n2. The first byte sent by our base station did not always correspond to the first byte read by our remote station.\n\nPart of the reason these two problems caused us so much pain was that we had elected to communicate by sending a struct over Bluetooth. This meant that getting the correct values depended completely on byte order, unlike in something like a JSON encoding, where the relative position of data could be preserved.\n\nWhen developing our solution, the first of these problems caused a number of strange behaviours, such as a massive delay between the initial push of the analog joystick and the servo activating, as well as the remote station randomly indicating it had been sent the done signal. These issues went away once we over sampled our Bluetooth signal (we landed at a rate of about 100Hz). This prevented the Bluetooth buffer from growing too large which caused delay, and upon overflow, incorrect values. Because we prevent our receive task from reading the next message until the servos have been given new values, we also had to have our control task update at a similarly high rate. In the future it may be worth exploring a slower control rate combined with aggregating received messages.\n\nThe second issue of byte alignment we solved by developing a simple communication protocol.\n\n## Communication Protocol\n\nA struct was used to communicate our data over Bluetooth. We used a four byte header for alignment. Shown below are the definitions of the struct and relevant constants.\n\n```lang:c-readonly\n#define MESSAGE_HEADER ((u32) 0x04030201)\n#define MESSAGE_DONE   0b00000001\n#define MESSAGE_LASER  0b00000010\n\ntypedef struct Message Message;\nstruct Message {\n#ifdef MESSAGE_SENDER\n    u32 header;\n#endif\n    s8 u_x;\n    s8 u_y;\n    s8 m_x;\n    s8 m_y;\n    u8 flags;\n};\n```\n\nFor our data values we selected as efficient of integer types as reasonably possible. Our analog stick values come from fixed point calculations, meaning they are guaranteed to be between -128 and 127, which means a single signed byte is all that is needed to communicate each stick position. We send the done flag and laser state in a single shared byte, as this is the smallest reasonable encoding for that binary data.\n\nThe 4-byte header provides a means of synchronizing the remote and base stations. Having the remote station wait until it has correctly read the header will help guarantee data correctness. We started with an 8-byte header that simply counted from 1 to 8. Immediately we ran into an issue of endianness, as a u64 of 0x0102030405060708 is actually encoded low byte first in memory on our boards. Since we were reading these bytes one at a time at the remote station we had to reverse the order of our header value. Once we had a working system we lowered the header down to 4 bytes and found there was no loss in correctness. More clever schemes for alignment could be devised. Two that we considered are as follows:\n\n - The Bluetooth modules seems to provide a reliable connection, meaning we could attempt to synchronize only once at startup and then trust that we will receive every byte in alignment.\n - We could use a single byte for alignment, such as 0xFF, and to ensure correctness enforce the policy that all fields of our message struct are never allowed to encode this value.\n\nUltimately,  we preferred our solution for its simplicity and reliability. In terms of implementing this protocol, the main work rested on the remote station. Its process of receiving bytes can be modeled using a simple state machine, shown below.\n\n![State Machine](/static/blog/rtos1/state-diagram.jpg)\n\nThe four-byte header precedes each message. One drawback to this design is that if the remote station misses the header for any reason, that message will be skipped and the information will be lost. If the remote station successfully sees the header, the next five bytes it reads will be the message data, which it will subsequently map to servo positions and the laser state.\n\nThe implementation of send for this protocol is provided below. We send the struct byte by byte over Bluetooth. If we assume our receiver will similarly copy our bytes into a buffer of the same type, this has the nice feature of not caring about endianness, so long as the client and host agree. \n\n```lang:c-readonly\nvoid send() {\n    digitalWrite(LOGIC_SEND, HIGH);\n    // Write each byte of current message onse at a time\n    u8 * buffer = (u8 *) &current_message;\n    u16 i;\n    for (i = 0; i < sizeof(Message); i++) {\n        Serial1.write(buffer[i]);\n    }\n    digitalWrite(LOGIC_SEND, LOW);\n}\n```\n\nThe receive function is slightly more complex. First it must correctly implement the aforementioned state machine, as well as the function should not block if serial input from the Bluetooth is not available. The later issue is nicely resolved using static variables. For ease of implementation we generalize the first four states into a single handler.\n\n```lang:c-readonly\nvoid receive() {\n\n    static int i = 0;\n    static int state = header1;\n\n    digitalWrite(LOGIC_RECEIVE, HIGH);\n    if (current_message == NULL) {\n        u8 * buffer = (u8 *) &buffer_message;\n        while (Serial1.available()) {\n            switch(state) {\n                case header1:\n                case header2:\n                case header3:\n                case header4:\n                    if (Serial1.read() == state) {\n                        state++;\n                    } else {\n                        state = header1;\n                    }\n                    break;\n                case data:\n                    // Read as much as is available\n                    while (Serial1.available()) {\n                        buffer[i++] = Serial1.read();\n                        if (i == sizeof(Message)) {\n                            current_message = &buffer_message;\n                            state = header1;\n                            i = 0;\n                            digitalWrite(LOGIC_RECEIVE, LOW);\n                            return;\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    digitalWrite(LOGIC_RECEIVE, LOW);\n}\n```\n\nIt is worth noting that both functions above provide code for setting a pin high when the function is entered, and low when the function returns. This is used for observations using the logic analyzer in the following section.\n\n## CPU Utilization\n\nTiming measurements were taken using both internal software and an external logic analyzer. Low CPU utilization is preferred in order to save power. In real world real-time systems, power consumption translates directly to cost. Additionally, low CPU utilization will allow for additional tasks in the project.\n\n### Base Station\n\nThe base station\'s two tasks, sample and send, were both set to run periodically every 16 milliseconds (approximately 60Hz). As previously mentioned, at the beginning of each task, a digital output pin was set to high, and at the end of each task that same pin was set to low. A Saleae logic analyzer was used to record these pin level changes and measure the durations of the two tasks. From the screenshot below, it can be seen that the time triggered scheduler does not guarantee precise periods. In this instance, the experimental periods of sample and send were 17.11ms and 16.08ms, respectively. \n\n![Logic 1](/static/blog/rtos1/logic-1.png)\n\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the sample task took 907 μs and the execution of the send task took 57.5 μs. It makes sense that sample takes longer because it has to obtain the state of multiple IO devices, as well as apply four low pass filters. In contrast, send simply has to send 9 bytes of data to the built-in UART.\n\nFrom these measurements, the CPU utilization can be calculated as\n\n```math\npercent used = ((Sample_duration / Sample_period) + (Send_duration / Send_period)) × 100%\n```\n\nUsing the measurements below, the CPU is in use 5.66% of the time. That translates to 94% idle time. Note that this is a rough value because of the inconsistency in the scheduler. A more accurate value could be estimated by averaging more samples from the logic analyzer.\n\n![Logic 2](/static/blog/rtos1/logic-2.png)\n\n### Remote Station\n\nThe remote station\'s two tasks, control and receive, were both set to run periodically every 10 milliseconds (approximately 100Hz).  As explained above, the higher frequency of the remote station tasks versus the base station tasks ensured an acceptable level of responsiveness in the IO devices and prevented the Bluetooth buffer from filling up.\n\nDepicted below, the experimental periods of control and receive were 9.343ms and 10.16ms, respectively. \n\n![Logic 3](/static/blog/rtos1/logic-3.png)\n\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the control task took 193 μs and the execution of the receive task took 55 μs. It makes sense that control takes longer because it has to adjust the state of multiple IO devices, whereas receive simply has to read from the UART. It is also worth noting that the computation time of control varies significantly. This is because on some calls the servo is not ready to receive a new position, which decreases the computation cost significantly. \n\nUsing the same equation as above, and the measurements listed below, CPU utilization was found to be 2.61%, which translates to roughly 97% idle time. \n\n![Logic 4](/static/blog/rtos1/logic-4.png)\n\nWe also measured our percentage of idle time in software. We used a simple process to determine this.\n\n1. We recorded the time in milliseconds prior to entering the main loop.\n2. Each time the time triggered scheduler returns with an idle time duration we add it to an ongoing sum.\n3. When we exit the main loop we record the end time in milliseconds.\n4. We calculated idle percentage as:\n\n```math\npercent idle = idle time / (start time - end time) × 100%\n```\n\nUsing this measurement method, we found that on average our base station was idle 93% of the time and our remote station was idle 98% of the time. These correlate closely with the results obtained from the logic analyzer (94% and 97%). Looking at our logical analyzer results it is clear that sampling inputs and controlling the servos is taking up the large majority of the processing time. If we wanted to improve our CPU utilization, this would be our starting point.\n\n# Conclusion\n\nNow that we have completed project 1 we are preparing and planning for project 2 where we will expand upon our current TTA, developing it into our own simple real-time operating system.\n\n# References\n\n\\[1\\] M. Cheng, "Project 3", *Webhome.csc.uvic.ca*, 2019. \\[Online\\]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. \\[Accessed: Apr-2019\\].\n\n\\[2\\] E. Hughes, "Introduction to Fixed Point Math", 2014. \\[Online\\]. Available: https://www.youtube.com/watch?v=bbFBgXndmP0. \\[Accessed: Apr-2019\\].',
        plainTxt: 'Author&#39;s Note\nThis blog post is part one in a series originally put together for the University of Victoria&#39;s CSC 460 course. The original content was publishd February 6 2019 by Torrey Randolph and myself. As that webpage no longer exists I am now hosting the content here.\nHere are links to part 2 and part 3.\n\nIntroduction\nThe goal of project 1 was to familiarize ourselves with the hardware and software interfaces we would be using throughout the semester. This project was broken in to two phases, details of which are provided below. This introductory section breaks down the software, hardware, and shared design decisions that were used to complete project 1.\nIn phase 1 we integrate these elements into a working solution. We control and aim a laser using an analog stick and detect the laser using a photocell. In phase 2 we create a similar solution, only this time we split the components across two boards and connect them together over Bluetooth.\nSoftware Dependencies\nWe took advantage of the software ecosystem provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\nVS Code: We opted to move away from Arduino IDE to a more developed code editor after completing exercises 1 through 5. Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\nAVR Toolchain: In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR micro-controllers. AVR Libc is the backbone of the Arduino libraries. We included the source code of relevant Arduino libraries with our projects for ease of integration with hardware. These libraries include ArduinoCore-avr, Servo, and LiquidCrystal. The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\nMekpie: Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \nSaleae Logic: This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\n\nHardware\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\n - 2x Arduino Mega 2560 boards: Only one of these was needed in phase 1, but phase 2 required the creation of a base and remote station.\n - 2x SG-90 Micro Servos in a pan and tilt module: These two servos are used to aim a mounted KY-008 Laser.\n - 2x HC-06 Bluetooth modules: These two Bluetooth modules are used to communicate between the base and remote stations in phase 2.\n - Arduino LCD KeyPad Shield: The Liquid Crystal Display is used to display relevant information, such as the current X and Y values of the analog stick.\n - Arduino KY-023 Joystick: An analog joystick used to control the motion of the pan and tilt module.\n - KY-008 Laser: This laser is used to shoot at our photocell. \n - photocell: Used to detect the laser.\nFixed Point Operations\nThe AVR processor does not have built in support for floating point types. As a consequence, floating point operations are achieved using software. This has the drawback that performing floating point arithmetic is significantly slower than integer arithmetic, transforming 1-cycle instructions into 200 plus cycle instructions. This had a noticeable performance impact during exercise 4 when contrasting floating point analysis of an analog signal to integer analysis. When considering performance and our overarching goal of achieving low power consumption, it is in our interest to have as few floating point operations in our solution as possible.\nWhen considering how to approach calculations typically done with floating point types, such as a low pass filter, we decided that fixed point operation may fit our needs.\nFixed point types can be considered integer values that are scaled up and down to represent smaller values. For instance, a fixed point scale of 10 would mean that 15 represents 1.5, and 57 represents 5.7. For efficient transformation to and from a fixed point format embedded programmers typically use a scale that is a power of 2. This allows scaling to be done by bit shifting. Fixed point numbers used in this way are typically expressed in the form QI.F where Q is the &quot;sign&quot; bit (in the 2&#39;s complement sense), I is the integer bits, and F is the fractional bits. So our chosen fixed point format of Q7.8 translates to a 16-bit value of the form:\nmath\nSign bit → 0 Integer bits → 0000000 Fractional bits → 00000000\nThe implementation of the data type is quite straightforward. Q7.8 corresponds to a scale of 0x0100.\n```lang:c-readonly\n// [-128.996, 127.996]\ndefine Q78_SCALE_FACTOR 0x0100\n// Q7.8\ntypedef s16 Q78_t;\ndefine Q78(n) ((Q78_t) ((n) * Q78_SCALE_FACTOR))\n```\nWe provide a type definition and a conversion macro for convenience.  A macro is used rather than a function to allow for optimization of numeric constants. If a fixed point number is immediately added to or subtracted from a numeric constant and it is initialized using a macro, the numeric constants can be pre-applied by the compiler.\nFixed point numbers have several advantages, the first being that addition and subtraction are trivial. Integer addition and subtraction of fixed point values sharing the same scale work without additional effort. Multiplication and division requires a little more work, but not much. \n```lang:c-readonly\nQ78_t Q78_mul(Q78_t a, Q78_t b) {\n    s32 tmp_a = a;\n    s32 tmp_b = b;\n    s32 tmp_c = (tmp_a * tmp_b) / Q78_SCALE_FACTOR;\n    return (Q78_t) tmp_c;\n}\nQ78_t Q78_div(Q78_t a, Q78_t b) {\n    s32 tmp_a = a;\n    s32 tmp_b = b;\n    s32 tmp_c = (tmp_a * Q78_SCALE_FACTOR) / tmp_b;\n    return (Q78_t) tmp_c;\n}\nQ78_t Q78_lpf(Q78_t sample, Q78_t average, Q78_t factor) {\n    static Q78_t one = Q78(1);\n    return Q78_mul(sample, factor) + Q78_mul(average, (one - factor));\n}\n```\nThe key to these operations is ensuring that you do not overflow your intermediate values, hence both multiplication and division use 32-bit integers for intermediate values. In addition to multiplication and division operations, we also implement a simple low pass filter using fixed point values.\nThe core drawback of fixed point numbers is their limited range. For Q7.8 we can represent values between -128.996 and 127.996. This means that wherever we take advantage of fixed point numbers in our project we must ensure that our operands and results fit within that range.\nThe implementation of fixed point discussed here is based off a series of online lectures on the topic by Eli Hughes. Fixed point numbers are just one solution in a sea of possible ways of representing and computing the results of fractional arithmetic. We also looked into rational number formats, but ultimately preferred fixed point representations because of their simplicity.\nPhase 1\nOverview\nThe goal of phase 1 was to use an analog stick to control and aim a laser to shoot a photocell that could subsequently detect the shot. All of these components were integrated using a single Arduino board. Thanks to the five exercises completed prior to phase 1. producing our solution was a smooth process. The block diagram below shows the general setup of our system.\nphase 1 block diagram\nA 10kΩ resistor was used to create a voltage divider for our photocell. As the resistance of the photocell changes when light is shone on it, the voltage across the 10kΩ resistor changes. That voltage is reported by the Mega 2560, mapped to the range (0, 1023). When the photocell is hit by the laser, the voltage reported increases to above a certain threshold, which was determined by trial and error.\nphase 1 voltage divider\nPhase 1 featured a simple main loop where we sample the analog stick, adjust the servos, toggle the laser, and then check if our photocell has been hit. There are no delays in this process so we simply try to go through these steps as quickly as possible, and then repeat. This is a poor solution when considering power consumption, as the CPU is never idle. It is important that the LCD is only updated when the photocell actually changes state. We discovered this in an earlier implementation where updating the LCD on every iteration of our main loop resulted in an unintelligible output from the LCD.\nlang:c-readonly\nfor (;;) {\n    map_servo_pan(sample_stick_u_x(), 0, STICK_U_OFFSET_X);\n    map_servo_tilt(-sample_stick_u_y(), 0, STICK_U_OFFSET_Y);\n    if (stick_u_down()) {\n        set_laser(ON);\n    } else {\n        set_laser(OFF);\n    }\n    if (photocell_hit()) {\n        lcd.clear();\n        lcd.print(&quot;Hit :O&quot;);\n        set_laser(OFF);\n        break;\n    }\n}\nOur sampling method for the analog sticks was established during exercise 4. We use a combination of a low pass filter and a clamp. For efficient computing, these computations are performed using fixed point values. After reading the raw analog value, we scale it down so that it will fit within the fixed point range, and then offset it so that the values are centred at 0. This makes more efficient use of the signed fixed point range.\nAfter reading, scaling, and offsetting our value we pass it through a simple low pass filter. The low pass filter is implemented as a simple rolling average function. Passing the value through the low pass filter reduces noise and gets us smoother feeling control with the stick. We pass all values into the low pass filter, including those that fall into the dead zone. This increases the accuracy of our rolling average.\nThe previously mentioned dead zone is a small region around the zero signal of the stick, that is clamped down to 0. This clamping combats two issues with analog inputs. The first is that the sticks have some noise in their input signal, even when at rest. This means that the measured value can be greater or less than 0 even if no one is touching the stick. Additionally, the sticks do not always come to rest at the exact same position due to friction, wear, and manufacturing imperfections. A dead zone mitigates these issues.\nOur dead zone is implemented using a clamp. We similarly clamp the maximum value slightly below the theoretical maximum. This ensures that when you push the stick to the furthest edge in any direction we return the same maximum value.\nPutting all of these decisions together we end up with the following implementation.\n```lang:c-readonly\nint sample_stick_u_x() {\n    static Q78_t rolling_x = Q78(0);\n    static Q78_t sample_x  = Q78(0);\n    sample_x  = Q78((analogRead(STICK_U_PIN_X) - STICK_U_OFFSET_X) / STICK_SCALE);\n    rolling_x = Q78_lpf(sample_x, rolling_x, STICK_LFP_FACTOR);\n    int x     = Q78_to_int(rolling_x);\n    if (x &lt; 0) {\n        x = clamp(x + STICK_U_DEADZONE, STICK_U_MIN_X, 0);\n    } else if (x &gt; 0) {\n        x = clamp(x - STICK_U_DEADZONE, 0, STICK_U_MAX_X);\n    }\n    return x;\n}\n```\nCorrectly performing these operations requires we measure out constants for each analog stick. Namely their minimum, maximum, and resting values. We determined these values using a separate program, and recorded the constants for each of our two sticks. This ensures we are obtaining the highest quality samples possible.\nWe map the stick values to the servo positions in an intelligent manner. The servo is moved in discrete steps. These steps enforce a maximum delta in position and a minimum delay between changes. This protects the servo from having its position changed too rapidly, which could damage it.\nThe implementation first checks to see if the servos are ready to have their positions changed again; this is done by keeping track of the last time they were called using Arduino&#39;s millis function. If sufficient time has passed we change the input into a fractional value between 0 and 1 and multiply this by our maximum delta. This means that small changes will map to slow rotation of the servo and large changes will map to fast rotation of the servo. We also clamp the delta again to ensure that we do not exceed our maximum delta due to incorrect arguments. Finally, we clamp the position before writing it to ensure we do not move the servo past its maximum range. Most of these operations are performed with fixed point values for efficiency.\nlang:c-readonly\nvoid map_servo_pan(int value, int min_value, int max_value) {\n    static int servo_pan_position = SERVO_PAN_CENTER;\n    static int last_call = 0;\n    int this_call = millis();\n    if (this_call - last_call &lt; SERVO_PAN_DELAY) {\n        return;\n    }\n    last_call = this_call;\n    Q78_t range = Q78(SERVO_PAN_MAX_SPEED);\n    Q78_t ratio = Q78_div(Q78(value - min_value), Q78(max_value));\n    Q78_t delta = Q78_mul(range, ratio);\n    servo_pan_position += clamp(Q78_to_int(delta), -SERVO_PAN_MAX_SPEED, SERVO_PAN_MAX_SPEED);\n    servo_pan_position =  clamp(servo_pan_position, SERVO_PAN_BOTTOM, SERVO_PAN_TOP);\n    servo_pan.writeMicroseconds(servo_pan_position);\n}\nPhase 2\nOverview\nThe goal of phase 2 was to separate the components into two stations, each with a Mega 2560 board and have them communicate over Bluetooth. Below are block diagrams of the two stations.\nphase 2 block diagram 1\nphase 2 block diagram 2\nThe base station includes the LCD, the joystick, the photocell, and one of the Bluetooth modules connected to a Mega 2560. The remote station consists of the pan and tilt servo motors, the laser, and the other Bluetooth module connected to another Mega 2560. The base station sends the joystick position to the remote station, which updates the servo motors and the laser positions correspondingly. In our implementation, the base station also sends a done flag when the photocell is hit by the laser to indicate that the program should gracefully shut down.\nPolling and TTA\nPhase 2 is to be implemented using a time triggered architecture (TTA). We make use of a scheduler developed by Neil MacMillan, a former TA of this course. In a TTA, tasks, implemented here as C functions, are run on a set period. In between these tasks the CPU is simply left to idle. A TTA has a number of benefits to real-time systems.\nThey are deterministic; a correct schedule will remain correct ad infinitum.\nThey are simple, especially compared to preemptive schedulers.\nThey are lightweight, as the scheduler itself has very little bookkeeping to accomplish.\n\nThe choice of a TTA led us to the decision of avoiding interrupts in both phase 1 and 2. TTA nicely integrates with polling-based algorithms, so for all our inputs and communication we use polling rather than interrupts to keep up with IO.\nIn our implementation the base station and remote station both alternated between two tasks. The base station had the task sample for collecting input from the analog stick and photocell, and send for packaging that information together and sending it over Bluetooth. The remote station had the task receive for collecting the information sent from the base station and control for using that information in the activation of the laser and servo motors. The actual implementation of these tasks rely on the same code presented in phase 1.\nWe elected to sample our analog stick at approximately 60Hz. This was done based off the knowledge that responsive video games typically target 60 frames per second. We then match this rate in sending out the input information to the remote station. In retrospect, it would be worth investigating sampling at an even higher rate, and sending at the same or slightly slower rate. The logic being that the low pass filter we apply to our analog stick input would be most effective on an over sampled input.\nOn the remote station we faced a number of issues actually receiving a message. We hypothesized that this was due to two core problems:\nThe Bluetooth and/or UART pin on the board had a limited buffer which could overflow and produce unexpected results.\nThe first byte sent by our base station did not always correspond to the first byte read by our remote station.\n\nPart of the reason these two problems caused us so much pain was that we had elected to communicate by sending a struct over Bluetooth. This meant that getting the correct values depended completely on byte order, unlike in something like a JSON encoding, where the relative position of data could be preserved.\nWhen developing our solution, the first of these problems caused a number of strange behaviours, such as a massive delay between the initial push of the analog joystick and the servo activating, as well as the remote station randomly indicating it had been sent the done signal. These issues went away once we over sampled our Bluetooth signal (we landed at a rate of about 100Hz). This prevented the Bluetooth buffer from growing too large which caused delay, and upon overflow, incorrect values. Because we prevent our receive task from reading the next message until the servos have been given new values, we also had to have our control task update at a similarly high rate. In the future it may be worth exploring a slower control rate combined with aggregating received messages.\nThe second issue of byte alignment we solved by developing a simple communication protocol.\nCommunication Protocol\nA struct was used to communicate our data over Bluetooth. We used a four byte header for alignment. Shown below are the definitions of the struct and relevant constants.\n```lang:c-readonly\ndefine MESSAGE_HEADER ((u32) 0x04030201)\ndefine MESSAGE_DONE   0b00000001\ndefine MESSAGE_LASER  0b00000010\ntypedef struct Message Message;\nstruct Message {\nifdef MESSAGE_SENDER\nu32 header;\nendif\ns8 u_x;\ns8 u_y;\ns8 m_x;\ns8 m_y;\nu8 flags;\n};\n```\nFor our data values we selected as efficient of integer types as reasonably possible. Our analog stick values come from fixed point calculations, meaning they are guaranteed to be between -128 and 127, which means a single signed byte is all that is needed to communicate each stick position. We send the done flag and laser state in a single shared byte, as this is the smallest reasonable encoding for that binary data.\nThe 4-byte header provides a means of synchronizing the remote and base stations. Having the remote station wait until it has correctly read the header will help guarantee data correctness. We started with an 8-byte header that simply counted from 1 to 8. Immediately we ran into an issue of endianness, as a u64 of 0x0102030405060708 is actually encoded low byte first in memory on our boards. Since we were reading these bytes one at a time at the remote station we had to reverse the order of our header value. Once we had a working system we lowered the header down to 4 bytes and found there was no loss in correctness. More clever schemes for alignment could be devised. Two that we considered are as follows:\nThe Bluetooth modules seems to provide a reliable connection, meaning we could attempt to synchronize only once at startup and then trust that we will receive every byte in alignment.\nWe could use a single byte for alignment, such as 0xFF, and to ensure correctness enforce the policy that all fields of our message struct are never allowed to encode this value.\n\nUltimately,  we preferred our solution for its simplicity and reliability. In terms of implementing this protocol, the main work rested on the remote station. Its process of receiving bytes can be modeled using a simple state machine, shown below.\nState Machine\nThe four-byte header precedes each message. One drawback to this design is that if the remote station misses the header for any reason, that message will be skipped and the information will be lost. If the remote station successfully sees the header, the next five bytes it reads will be the message data, which it will subsequently map to servo positions and the laser state.\nThe implementation of send for this protocol is provided below. We send the struct byte by byte over Bluetooth. If we assume our receiver will similarly copy our bytes into a buffer of the same type, this has the nice feature of not caring about endianness, so long as the client and host agree. \nlang:c-readonly\nvoid send() {\n    digitalWrite(LOGIC_SEND, HIGH);\n    // Write each byte of current message onse at a time\n    u8 * buffer = (u8 *) &amp;current_message;\n    u16 i;\n    for (i = 0; i &lt; sizeof(Message); i++) {\n        Serial1.write(buffer[i]);\n    }\n    digitalWrite(LOGIC_SEND, LOW);\n}\nThe receive function is slightly more complex. First it must correctly implement the aforementioned state machine, as well as the function should not block if serial input from the Bluetooth is not available. The later issue is nicely resolved using static variables. For ease of implementation we generalize the first four states into a single handler.\n```lang:c-readonly\nvoid receive() {\nstatic int i = 0;\nstatic int state = header1;\n\ndigitalWrite(LOGIC_RECEIVE, HIGH);\nif (current_message == NULL) {\n    u8 * buffer = (u8 *) &buffer_message;\n    while (Serial1.available()) {\n        switch(state) {\n            case header1:\n            case header2:\n            case header3:\n            case header4:\n                if (Serial1.read() == state) {\n                    state++;\n                } else {\n                    state = header1;\n                }\n                break;\n            case data:\n                // Read as much as is available\n                while (Serial1.available()) {\n                    buffer[i++] = Serial1.read();\n                    if (i == sizeof(Message)) {\n                        current_message = &buffer_message;\n                        state = header1;\n                        i = 0;\n                        digitalWrite(LOGIC_RECEIVE, LOW);\n                        return;\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    }\n}\ndigitalWrite(LOGIC_RECEIVE, LOW);\n}\n```\nIt is worth noting that both functions above provide code for setting a pin high when the function is entered, and low when the function returns. This is used for observations using the logic analyzer in the following section.\nCPU Utilization\nTiming measurements were taken using both internal software and an external logic analyzer. Low CPU utilization is preferred in order to save power. In real world real-time systems, power consumption translates directly to cost. Additionally, low CPU utilization will allow for additional tasks in the project.\nBase Station\nThe base station&#39;s two tasks, sample and send, were both set to run periodically every 16 milliseconds (approximately 60Hz). As previously mentioned, at the beginning of each task, a digital output pin was set to high, and at the end of each task that same pin was set to low. A Saleae logic analyzer was used to record these pin level changes and measure the durations of the two tasks. From the screenshot below, it can be seen that the time triggered scheduler does not guarantee precise periods. In this instance, the experimental periods of sample and send were 17.11ms and 16.08ms, respectively. \nLogic 1\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the sample task took 907 μs and the execution of the send task took 57.5 μs. It makes sense that sample takes longer because it has to obtain the state of multiple IO devices, as well as apply four low pass filters. In contrast, send simply has to send 9 bytes of data to the built-in UART.\nFrom these measurements, the CPU utilization can be calculated as\nmath\npercent used = ((Sample_duration / Sample_period) + (Send_duration / Send_period)) × 100%\nUsing the measurements below, the CPU is in use 5.66% of the time. That translates to 94% idle time. Note that this is a rough value because of the inconsistency in the scheduler. A more accurate value could be estimated by averaging more samples from the logic analyzer.\nLogic 2\nRemote Station\nThe remote station&#39;s two tasks, control and receive, were both set to run periodically every 10 milliseconds (approximately 100Hz).  As explained above, the higher frequency of the remote station tasks versus the base station tasks ensured an acceptable level of responsiveness in the IO devices and prevented the Bluetooth buffer from filling up.\nDepicted below, the experimental periods of control and receive were 9.343ms and 10.16ms, respectively. \nLogic 3\nMeasurements of the timing markers in the above screenshot are shown below. The execution of the control task took 193 μs and the execution of the receive task took 55 μs. It makes sense that control takes longer because it has to adjust the state of multiple IO devices, whereas receive simply has to read from the UART. It is also worth noting that the computation time of control varies significantly. This is because on some calls the servo is not ready to receive a new position, which decreases the computation cost significantly. \nUsing the same equation as above, and the measurements listed below, CPU utilization was found to be 2.61%, which translates to roughly 97% idle time. \nLogic 4\nWe also measured our percentage of idle time in software. We used a simple process to determine this.\nWe recorded the time in milliseconds prior to entering the main loop.\nEach time the time triggered scheduler returns with an idle time duration we add it to an ongoing sum.\nWhen we exit the main loop we record the end time in milliseconds.\nWe calculated idle percentage as:\n\nmath\npercent idle = idle time / (start time - end time) × 100%\nUsing this measurement method, we found that on average our base station was idle 93% of the time and our remote station was idle 98% of the time. These correlate closely with the results obtained from the logic analyzer (94% and 97%). Looking at our logical analyzer results it is clear that sampling inputs and controlling the servos is taking up the large majority of the processing time. If we wanted to improve our CPU utilization, this would be our starting point.\nConclusion\nNow that we have completed project 1 we are preparing and planning for project 2 where we will expand upon our current TTA, developing it into our own simple real-time operating system.\nReferences\n[1] M. Cheng, &quot;Project 3&quot;, Webhome.csc.uvic.ca, 2019. [Online]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. [Accessed: Apr-2019].\n[2] E. Hughes, &quot;Introduction to Fixed Point Math&quot;, 2014. [Online]. Available: https://www.youtube.com/watch?v=bbFBgXndmP0. [Accessed: Apr-2019].\n',
        route: '/blog/rtos1',
        layout: '../../layouts/Blog',
        title: 'Creating an RTOS (Pt. 1)',
        subtitle: 'Exploring a Time Triggered Scheduler using Arduino and finding the usecase for a barebones RTOS',
        blog: true,
        date: '05-19-2019',
    }),
    rtos2: new Page({
        name: 'rtos2',
        content: '> # Author\'s Note\n>\n> *This blog post is part two in a series originally put together for the University of Victoria\'s CSC 460 course. The original content was publishd March 13 2019 by [Torrey Randolph](https://github.com/torreyr) and myself. As that webpage no longer exists I am now hosting the content here.*\n>\n> *Here are links to [part 1](/blog/rtos1) and [part 3](/blog/rtos3).*\n\n# Introduction \n\nThe goal of project 2 was to design and implement a real time operating system (RTOS) and a corresponding API to be used in the final project, project 3. The RTOS created for this project is an extension of a time-triggered architecture (TTA) scheduler, with some important new features including support for non-periodic tasks as well as multiple instances of the same task. Many design decisions had to be made including how to represent tasks, what scheduling algorithm to use, and how to keep track of time. These will be described in more detail in the sections below. This report will also cover the strategies used to test our implementation and some hardships we came across during the process.\n\nThe only special hardware needed for this project was a single Arduino Mega 2560 board and a Saleae USB logic analyzer. Software dependencies are the same as in project 1, they can be seen listed [here](/blog/rtos1).\n\n# RTOS\n\n## Overview\n\nThe simplicity of a TTA lends itself to a simple API, we wanted our RTOS keep this quality. TTA implementations are broken into two phases: a declarative phase, where tasks are defined for the scheduler, and a run phase, or runtime phase, where the scheduler manages the task. What makes our solution truly an RTOS and not just a scheduler is our emphasis on that runtime phase. This will become especially clear when we discuss our much more dynamic conception of tasks when compared to a standard TTA implementation. This focus also influenced our core API and what services we wanted to provide the user beyond simply calling a function at the right time, namely we built the RTOS from the ground up with instrumentation in mind and placed an emphasis on improving the debug experience of lower level C development. The following is a condensed overview of the RTOS API.\n\n```lang:c++-readonly\nnamespace RTOS {\n  \n    void init();\n    void dispatch();\n    void halt();\n    void trace();\n    void error();\n    void debug_print(const char * fmt, ...);\n    void debug_led(bool led);\n  \n    namespace Registers {\n        extern Event_t triggers;\n    }\n  \n    namespace UDF {\n        void trace(Trace_t * trace);\n        bool error(Trace_t * trace);\n    }\n}\n```\n\nThe functions init, dispatch, and halt are all essential to the basic operation of the RTOS, taking the responsibility of initializing resources, starting scheduling, and safely shutting down the RTOS respectively. We were selective about what C++ features we wanted to take advantage of for the RTOS, but namespaces were one we decided to capitalize on. Outside of simply helping avoid name collisions, namespaces serve our design to organize more traditional procedural programming constructs into something more familiar to programmers who have seen object oriented interfaces. \n\nThe functions trace and error allow both the internals of the RTOS, and user programs to efficiently communicate information with the developer. This could be scheduling information, debug messages, or runtime checks. How these functions works, along with their sister functions in the User Defined Function (UDF) namespace is detailed in the Tracing section of the report.\n\nOutside of these functions, the core functionality of the RTOS involves Tasks.\n\n## Tasks\n\nIn a standard TTA tasks are defined by an implementation, commonly a function, a period, and an offset. Our RTOS includes these properties and more in order to extend the functionality of a TTA. The comprehensive set of properties are viewable as the fields in the Task_t struct:\n\n```lang:c++-readonly\nstruct Task_t {\n    task_fn_t fn;   // A pointer to the task funtion\n    void * state;   // A pointer to the task\'s associated state\n    Event_t events; // The events that cause this task to be scheduled\n    i16 period_ms;  // The schedule period of this task (in milliseconds)\n    i16 delay_ms;   // The delay before this task is scheduled\n    // "hidden" fields\n    struct {\n        bool first;\n        u8 instance; // Used to identify a task during a trace\n        i64 last;    // The last time this task was run\n        i16 maximum; // The maximum runtime of this task so far\n    } impl;\n};\n```\n\nThe final three fields of the Task are meant to be used only by the RTOS for bookkeeping. The fields work as follows:\n\n - `fn`: Like in TTA this defines the implementation, a function pointer that will run every time the task is scheduled. These functions are provided their containing Task_t struct as an argument allowing them to self modify and mutate. Additionally, we allow this function to determine whether the Task should be run again by returning a boolean result.\n - `state`: Providing room in Task_t for the user to store an arbitrary pointer allows for instancing of tasks. This is discussed in more detail later in the report.\nevents: We provide a mechanism for reactive computation by way of event-driven tasks. The events field of Task_t define what events a Task responds to.\n - `period_ms`: The period is a standard field needed for a periodic TTA. Our RTOS provides accurate scheduling up to one ms.\ndelay_ms: Similar to period, delay is another standard field needed for TTA in order to offset Tasks from one another.\n - `first`: Some behaviour of Tasks depends on whether it is being run for the first time. For instance a periodic time without delay will be run at time 0. \ninstance: In order to efficiently trace a Task schedule we want to be able to identify a Task by a unique identifier. We reserve one byte to indicate the Task instance. This is not referring to the type of instancing provided by the state field, this instance refers to every instance of Task that exists in the system.\n - `last`: This field records the last time this Task was run allowing the RTOS to easily calculate its next run time.\n - `maximum`: This field records the longest time this Task has ever taken to run. For standard periodic tasks this does not impact the Task\'s execution, but for less essential Tasks this gives the RTOS the ability to make a reasonable guess as to whether a Task can fit into an idle gap.\n\nA  key design decision in our RTOS is to represent all types of Tasks with a single construct. A Task is dispatched to the RTOS in two situations. First explicitly, when the user defines the task and then calls Task::dispatch. Second automatically, after a task is run it is reconsidered by the RTOS. This means that a task function can modify its associated Task_t struct in anyway it sees fit, allowing one type of task to become any other type of task. Additionally, tasks can be freely created and destroyed as the RTOS is running, simply by calling the appropriate functions from a task function.\n\nThis high level of dynamism means that the RTOS needs to support quick allocation and deallocation of Tasks as well as efficient means of bookkeeping different task types. Rather than depending on the heavyweight solution of malloc and free, we utilize a generic Memory Pool allocator (also sometimes referred to as a refrigerator allocator) to solve both of these problems. Memory Pool allocators can refer to slightly different systems depending on where you look. Our solution focuses on the allocation of like-sized memory chunks. We divide a region of memory into equal size chunks. Each chunk has enough room for the desired object and a pointer to another chunk. By chaining theses chunk pointers together we effectively create a linked list of available chunks. Figure 1 below helps illustrate this setup.\n\n![Memory Pool Layout](/static/blog/rtos2/memory-pool-layout.png)\n\nAllocating memory is as simple as popping the head off the list, and deallocating memory is as simple as prepending a chunk back on to the list. This allocation scheme is significantly simpler and faster than more generic allocation schemes, it also has a hidden benefit. When a chunk is allocated its associated chunk pointer is no longer being used by the allocator, this leaves it free to be used to help construct new linked list structures. This is the methodology used by the RTOS for task allocation and management.  Tasks are allocated using a Memory Pool, and then organized into linked lists using their associated chunk pointers.\n\n## Periodic Tasks\n\nPeriodic tasks are time-sensitive tasks that the RTOS aims to always run on time. The are the highest possible priority task. A periodic task is defined by its period and delay. The delay of a periodic task acts as its offset, determining how much time occurs between the task being created and being run. Dynamically created periodic tasks measure their start time from the scheduled time of the task that created them. The scheduled time of a task is the theoretically best time a task would run, not its actual time. This means that if there is a periodic task that dynamically creates another periodic task, that task will still run at the expected time.\n\nThe following is an example of creating a periodic task:\n\n```lang:c++-readonly\nusing namespace RTOS;\n\nTask_t * my_task = Task::init("my_task", my_task_fn);\nmy_task->period_ms = 1000;\nmy_task->delay_ms  = 500;\nTask::dispatch(my_task);\n```\n\n## Delayed Tasks\n\nDelayed tasks are another form of time-sensitive tasks. Delayed tasks were added to the TTA to provide a clear method of declaring a "one-shot" task, ie. a task that is run only once. Our implementation of delayed tasks is more flexible however. A delayed task will be run jut once only if no new delay is supplied, or the task function itself returns false. This allows for a delayed task to be run an arbitrary number of times, waiting on a condition for instance, or run with different delays each time. \n\nDelayed tasks are created in the same manner as periodic tasks, only their period_ms field is left at 0. \n\n## Event Driven Tasks\n\nEvent driven tasks provide a way for our RTOS to respond to urgent events, such as an interrupt occurring.  Our RTOS allows interrupts to occur at most times, specifically interrupts can occur during the run time of any task as well as during idle time. This opens up our design to race-conditions. To avoid these painful issues we allow interrupts to only do two things: read arbitrary data and dispatch an event. There is no strict check to ensure that the user does not violate this rule, so it is on them to ensure their program upholds this convention. Event code is carefully written to allow read and writing from interrupts, disabling interrupts at key points in time if necessary.\n\nEvents in our system are represented as bits at a specific memory location. The definition for events is provided below:\n\n```lang:c++-readonly\ntypedef NUMTYPE_U(RTOS_MAX_EVENTS) Event_t;\n\nnamespace Event {\n    Event_t init(const char * handle);\n    void dispatch(Event_t e);\n}\n```\n\nThe number of bytes used for events depends on the desired maximum allowed events. We allow for 8, 16, 32, and 64 events corresponding to the different integer sizes. The Event API is limited to two functions, one for creating events and another for dispatching them. Internally the RTOS uses a variable to represent dispatched events. This variable is never read from or written to without first disabling interrupts.\n\nIn order for events to be useful tasks need to be able to respond to them. If a task has no delay and no period than it is allowed to become an event-driven task. A task sets its event field with the bits corresponding to the events it wants to listen to. When that even fires it will be scheduled in the next available idle gap, so long as no delayed task is waiting to run.\n\nEach event can only drive a single task, but a task can listen to multiple events. When an event-driven task is run a the RTOS::Registers::triggered variable stores what tasks triggered the task to run. After running the event is considered cleared and will not trigger the task again until the event is dispatched again.\n\nThe following is an example of creating an event-driven task that listens for two different events:\n\n```lang:cc++-readonly\nusing namespace RTOS;\n\nEvent_t event_1 = Event::init("event_1");\nEvent_t event_2 = Event::init("event_2");\n\nTask_t * my_task = Task::init("my_task", my_task_fn);\nmy_task->events = event_1 | event_2;\nTask::dispatch(my_task);\n```\n\n## Keeping State\n\nIn a normal TTA, each run of a task is a new activation of that task; tasks have no way to keep track of their history, or their state. This also means that two tasks with the same task function will have the same effect. By providing a pointer for state on Task_t we allow tasks to maintain state and have a notion of different instances.\n\n## Keeping Time\n\nTime is an important part of a real time operating system. The operating system has to have a concept of time, however that is implemented. Our RTOS uses a hardware timer set to interrupt every millisecond to keep track of the current time. This timer increments a global variable representing the time in milliseconds since the RTOS was dispatched. Two factors had to be considered while developing this system: the precision of the timer and the size of our variable.\n\nThe crystal oscillator on the ATMega2560 runs at 16 MHz. Hardware timers can be configured to use the CPU clock directly or to use a scaled version of that clock. We configured Timer/Counter 1 on the ATMega2560 to use a clock with one-64th the frequency of the CPU clock. This, along with its interrupt set to trigger when the counter reached 250, produced a timer interrupt that went off every one millisecond. One millisecond precision was found to be enough for our system, providing us decent precision while limiting the CPU time spent updating our global time variable.\n\nWhen deciding what size of variable to use, we calculated how long various sizes would take to overflow. Only signed integers were considered because the time is used in many arithmetic computations. With a 32-bit field, the largest number that can be represented is 2,147,483,647. That equates to 24 days of time-keeping before our variable would overflow. While that would be sufficient for the purposes of this project, we decided to instead use a signed 64-bit field, giving us roughly 292 years of time-keeping ability.\n\n## Scheduling\n\nThe RTOS scheduling procedure is where we achieve most of the desired functionality. The following is the source code for thee RTOS inner loop:\n\n```lang:c++-readonly\nvoid dispatch() {\n\n    Time::init();\n\n    MAIN_LOOP: for (;;) {\n\n        i64 this_time = Time::now();\n        i64 idle_time = 0xFFFF;\n\n        Task_t * task;\n\n        task = Registers::periodic_tasks;\n        if (task != nullptr) {\n            i64 time_remaining = Task::time_remaining(task, this_time);\n            if (time_remaining <= 0) {\n                // We need to pop the task off the list before running the task\n                // Run will handle re-inserting it correctly\n                Registers::periodic_tasks = Task::cdr(task);\n                Task::run(task);\n                goto MAIN_LOOP;\n            } else {\n                idle_time = min(idle_time, time_remaining);\n            }\n        }\n\n        task = Registers::delayed_tasks;\n        if (task != nullptr) {\n            i64 time_remaining = Task::time_remaining(task, this_time);\n            if (time_remaining <= 0) {\n                if (Task::fits(task, idle_time)) {\n                    // We need to pop the task off the list before running \n                    // the task. Run will handle re-inserting it correctly\n                    Registers::delayed_tasks = Task::cdr(task);\n                    Task::run(task);\n                }   \n                goto MAIN_LOOP;\n            } else {\n                idle_time = min(idle_time, time_remaining);\n            }\n        }\n        task = Registers::event_tasks;\n        if (Registers::events) {\n            while (task != nullptr) {\n                if (task->events & Registers::events) {\n                    if (Task::fits(task, idle_time)) {\n                        Task::run(task);\n                    }\n                    goto MAIN_LOOP;\n                }\n                task = Task::cdr(task);\n            }\n        }\n        Time::idle(this_time, idle_time);\n    }\n}\n```\n\nThe scheduling procedure is broken into four key steps. Scheduling periodic tasks, scheduling delayed tasks, scheduling event tasks, and idling. By maintaining our periodic and delayed tasks in sorted order, where the first task in the list is the next to run, we only have to check if the first task in each of these lists is ready to run. Task have a Task::time_remaining function which roughly return:\n\n```math\ntime remaining = (last time run + delay + period) - now \n```\n\nThis means that a task is ready to run when its time remaining is equal to zero. We compare using less than or equal to for the case of a missed task. In reality this function is slightly more complex as periodic time begins at zero, and the notion of time remaining is not sensible for event-driven tasks.\n\nIf any task is successfully scheduled, or a task fails to fit within the remaining idle time, we immediately return to the start of the loop to ensure that our priority order is properly maintained. A task can fit if its maximum time is less than the current idle time. When first running a task our RTOS is naively optimistic, assuming the task will take zero milliseconds, but each run the maximum time is updated, and if that task does not fit in the idle time it will be skipped.\n\nWhen periodic or delayed tasks are run, they are removed from their respective lists, moving the next to run task to the top. They will be reinserted in sorted order by Task::run if necessary.  The same goes for adding event tasks that dynamically change to and from other task types. Note that because event tasks are prioritized first come first serve, we have to iterate over the entire event list in order to check if one needs to be scheduled. \n\nIf no task can currently run we idle until the next time sensitive task is ready to run. This is done using the following function:\n\n```lang:c++-readonly\nvoid idle_mode() {\n    set_sleep_mode(SLEEP_MODE_IDLE);\n    sleep_mode();\n}\n\nvoid idle(i64 this_time, i64 idle_time) {\n    // Get most accurate idle time\n    i64 now_time = now();\n    idle_time -= (now_time - this_time);\n\n    // Check if time has already passed by now\n    if (idle_time < 1) {\n        return;\n    }\n\n    // Delay\n    while(now() - now_time < idle_time && !Registers::events) {\n        idle_mode();\n    }\n}\n```\n\nDuring idle time we put the CPU into Idle Mode using the appropriate AVR Libc functions. This helps reduce power consumption. Because we keep time using an interrupt, we are guaranteed to idle for no more than one millisecond at a time. When we wake up we check whether the appropriate amount of time has passed or if an event has gone off, in which case we return to the scheduler.\n\nIf a task misses its scheduled time, an error is traced, however the task will maintain the schedule it would have had should it not have been missed. For instance if a task is expected to run every 1000 ms, runs for the first time at 2000 ms, but misses its second run, running instead at 3001 ms, it will still be scheduled for 4000 ms, not 4001 ms. This makes the RTOS scheduling much easier to predict even when some tasks experience slight jitter.\n\n## Tracing\n\nTracing occurs throughout the RTOS. Anytime a Task is created, started, or stopped, memory is allocated, the CPU is put into idle mode, all of these actions and more are traced. Tracing is done by updating a trace struct with appropriate values and then issuing a call to trace. This will call the UDF of the same name. It is up to the user programmer to decide what to do with tracing information. Additionally, we allow the user programmer to opt out of tracing using preprocessor directives allowing the RTOS to run without the overhead of tracing. The actions captured by tracing are best summarized by looking at the tagged union used to represent the data:\n\n```lang:c++-readonly\nenum Trace_Tag_t {\n    // Definitions\n    Def_Task,  // The creation of a task\n    Def_Event, // The definition of an event\n    Def_Alloc, // The allocation of memory\n    // Marks\n    Mark_Init,  // The start of the RTOS\n    Mark_Halt,  // RTOS exucution is about to stop\n    Mark_Start, // The start of a task\n    Mark_Stop,  // The end of a task\n    Mark_Event, // The occurence of an event\n    Mark_Idle,  // Scheduled idle time\n    Mark_Wake,  // Woke up from idle time\n    // Errors\n    Error_Max_Event,       // Maximum number of events exceeded\n    Error_Undefined_Event, // Undefined event dispatched\n    Error_Max_Alloc,       // Maximum memory allocation exceeded\n    Error_Max_Pool,        // Maximum pool allocation exceeded\n    Error_Null_Pool,       // Null pool or chunk pointer passed as argument\n    Error_Max_Task,        // Maximum tasks exceeded\n    Error_Null_Task,       // Null task passed as argument\n    Error_Invalid_Task,    // Invalid task configuration provided\n    Error_Duplicate_Event, // Two tasks act on the same event\n    Error_Missed,          // A task schedule was missed\n    // Debug\n    Debug_Message, // Used to send messages to the tracer\n};\n\ntypedef struct Trace_t Trace_t;\nstruct Trace_t {\n    Trace_Tag_t tag; // The trace tag\n    union {\n        union {\n            struct { const char * handle; };\n            struct { const char * handle; u8 instance; } task;\n            struct { const char * handle; Event_t event; } event;\n            struct { const char * handle; u16 bytes; } alloc;\n        } def;\n        union {\n            struct { u64 time; };\n            struct { u64 time; u16 heap; } init;\n            struct { u64 time; } halt;\n            struct { u64 time; u8 instance; } start;\n            struct { u64 time; u8 instance; } stop;\n            struct { u64 time; Event_t event; } event;\n            struct { u64 time; } idle;\n            struct { u64 time; } wake;\n        } mark;\n        union {\n            struct { Event_t event; } undefined_event;\n            struct { Event_t event; } duplicate_event;\n            struct { u8 instance; } invalid_task;\n            struct { u8 instance; } missed;\n        } error;\n        union {\n            struct { const char * message; };\n        } debug;\n    };\n};\n```\n\nThe Trace tags vary in purpose from scheduling information to runtime error checking. Definition traces, for when a user programmer defines a Task, Event, or allocates memory also provides a human readable handle which can be useful for visualizing trace results. We use a tagged union to try and minimize the overall memory footprint of Traces. The precise size of a Trace will vary between 12 and 18 bytes depending on the specified number of Events the user needs.\n\nError traces are provided to the user programmer even when normal tracing is disabled. These correspond to various unexpected events, such as running out of memory, or a task missing its scheduled time. It is up to the user program to decide how to react to these errors. The UDF error function is passed these traces, if it returns true the RTOS will continue execution, otherwise it will halt immediately. This allows programs to react in different ways to different error states. For instance some programs may wish to crash if a specific task is missed, but not crash for others. This system allows for that level of fine grained control.\n\nThe RTOS provides two built in methods of handling traces, pin tracing and serial tracing. With pin tracing the function Trace::configure_pin can be used to assign digital pins to specific tasks. If the UDF provides all traces to Trace::pin_trace, the RTOS will automatically set the appropriate digital pins high and low as tasks run. This makes integration with a logic analyzer trivial. \n\nSerial tracing will output the trace bytes directly to a serial port. We wrote a small python module that could decode the trace and keep a log. This module would print the trace in a JSON format to stdout as well as print RTOS debug messages to stderr. We combined this functionality with a small web server that served these logs and a small webpage for visualizing the results. To provide an idea of how this works, here is the logic analyzer results for one of our tests, compared to the visualized results from our python module:\n\n![logic 1](/static/blog/rtos2/logic-1.png)\n\n![webpage visualization](/static/blog/rtos2/webpage-trace.png)\n\nIn addition to plotting the trace of tasks we also used the webpage to display additional information, such as RTOS memory usage, and general statistics about CPU utilization and task times. This interface provides a sort of real time dashboard for the board, as the webpage can be updated as the board runs and traces arrive on the serial port. This became an indispensable tool during development.\n\n# Testing\n\n## Overview\n\nTime-sensitive applications are notoriously hard to test, let alone the RTOS running underneath them. However, to ensure that everything is working properly, testing is necessary. One popular way to test real-time systems is by having the system produce a trace of what is going on so that the user can visually analyze the results. To make sure the system behaves correctly and will not produce unintended results, developers try to force the system to exhibit bad behaviour. If the system has been implemented correctly, it will deal with these situations as predicted and produce an expected trace.\n\nTime-insensitive features or components of a software program can be tested without producing a trace and instead by writing unit tests. The unit tests described below used software assertions to verify expected behaviour of each component.\n\nFor any time-sensitive features, schedule tests were created to use traces produced by our RTOS to verify correct behaviour.  These tests can be set up to use any of the tracing methods described above as a verification method, as well as additional software assertions. The twenty-one schedule test cases below were ran multiple times during development to ensure systems were not broken in the process and that everything worked as expected after code was finalized.\n\n## Unit Tests\n\n### Event Tasks\n\nTests a number of functions involving events. Creates and asserts the uniqueness of events, tests dispatching them and ensuring and global variables for the RTOS are updated correctly. Tests that all of these actions produce correct traces. Also tests that error traces will occur if too many events are created, or an undefined event is dispatched.\n\n### Memory Tests\n\nTests the static and pool allocators provided by the RTOS.  The static allocator simply provides one time dynamic memory allocation without any ability to free memory. Pool allocators are tested to see if they provide usable, safe memory, and can be combined into lists and deallocated. All of these steps are checked for correct traces, and in the case of either the static allocator or pool allocator running out of memory, an error trace is expected.\n\n### Task Tests\n\nTests the creation of tasks, and ensues that RTOS global variables are updated correctly when tasks are dispatched. For instance periodic tasks are dispatched and their order is checked to ensure that the RTOS correctly sorts them. Event tasks are also tested to ensure that they appear in FIFO order and will create an error trace when two tasks attempt to listen to the same event.\n\n## Scheduling Tests\n\n### 01 - Single Periodic Task\n\nTests that a periodic task runs repeatedly and on time.\n\n\n### 02 - Multiple Periodic Tasks\n\nTests that two alternating periodic tasks run in the correct order and at the correct times.\n\n### 03 - Single Periodic Task with Offset\n\nTests that a periodic task with an initial delay runs at the correct times. For example, a task with a period of 500 milliseconds and an initial delay of 200 milliseconds should run at the following times: 200 ms, 700 ms, 1200 ms, 1700 ms, etc.\n\n### 04 - Overlapping Periodic Tasks\n\nTests that two periodic tasks scheduled to overlap each other will cause the second task to miss its deadline and an Error_Missed error to be sent to the user.\n\n### 05 - Defining Tasks in the Wrong Order\n\nTests that the scheduler schedules tasks in the correct order regardless of the order they were dispatched in. Two periodic tasks were created, each with a period of 500 milliseconds. One of the tasks, Task 2, also had an initial delay of 250 milliseconds. Though Task 2 was dispatched to the operating system before Task 1, the scheduler correctly ran Task 1 before Task 2.\n\n### 06 - Instances of a Single Task\n\nTests that two instances of a single task retain their separate states correctly. Two periodic tasks were created; Task 1\'s state field was assigned the value of true and Task 2\'s was assigned the value of false. Every time the task function was ran, depending on the instance of the task currently being executed, it asserted that the state field was true or false as expected. This demonstrated that two tasks sharing the same task function have separate states.\n\n### 07 - Event Occurring Prior to OS Dispatch\n\nTests that the operating system is able to remember events that may occur between the time that the operating system is initialized and dispatched.\n\n### 08 - Terminating Delayed Task\n\nTests that a single delayed task is run once at the correct time and then never run again.\n\n### 09 - Terminating Immediate Task\n\nTests that a single immediate task (a delayed task with delay_ms of zero) is ran once and then never run again.\n\n### 10 - Repeating Delayed Task\n\nTests that a single delayed task that creates itself is put back in the queue and ran again at the correct time.\n\n### 11 - Interrupt During Periodic Task\n\nTests that a periodic task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the periodic task completes. Furthermore, the periodic task is run at its next scheduled period.\n\n### 12 - Interrupt During Delayed Task \n\nTests that a delayed task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the delayed task completes.\n\n### 13 - A Long Task in a Short Idle Time\n\nTests the scheduler\'s ability to determine if a task will fit in a given idle time. In this test, a periodic task was created and schedule to run for 40 milliseconds every 500 milliseconds. An event-driven task was created and set to run for 500 milliseconds when triggered. Below, Figure 2 shows the correct sequence of events that occurred. At timing marker A1 the periodic task executed for 40 milliseconds. During that time, a timer interrupt went off, triggering the event. The periodic task completed its execution and then event-driven task ran for 500 milliseconds. When the event-driven task completed, the time was roughly 540. Though the periodic task was supposed to run at time 500, it missed its deadline due to the length of the event-driven task. The operating system will have noted the running time of the event-driven task and at the start of the next idle time, even though the event is triggered again, the scheduler correctly determines that it does not have time to run the event-driven task.\n\n![logic 2](/static/blog/rtos2/logic-2.png)\n\n### 14 - Multiple Interrupts in a Long Idle Time \n\nTests that an event-driven task runs multiple times during a single idle period if the event is triggered multiple times and the task fits within the time constraint.\n\n### 15 - Periodic Task Becoming Delayed \n\nTests that a periodic task can dynamically become a delayed task. A periodic task may set its period_ms field to zero and its delay_ms field to non-zero to transform from a periodic task to a delayed task.\n\n### 16 - Delayed Task Becoming Periodic\n\nTests that a delayed task can dynamically become a periodic task. A delayed task may set its period_ms field to non-zero to transform from a delayed task to ta periodic task. \n\n### 17 - Periodic Task Becoming Event-Driven\n\nTests that a periodic task can dynamically become an event-driven task. A periodic task may set its period_ms field to zero and its events field to the desired event(s) to transform from a periodic task to an event-driven task.\n\n### 18 - Event-Driven Task Becoming Delayed\n\nTests that an event-driven task can dynamically become a delayed task. An event-driven task may set its events field to zero and its delay_ms field to non-zero to transform from an event-driven task to a delayed task.\n\n### 19 - Delayed Task Becoming Event-Driven\n\nTests that a delayed task can dynamically become an event-driven task. A delayed task may set its events field to the desired event(s) to transform from a delayed task to an event-driven task.\n\n### 20 - Event-Driven Task Becoming Periodic\n\nTests that an event-driven task can dynamically become a periodic task. An event-driven task may set its events field to zero and its period_ms field to non-zero to transform from an event-driven task to a periodic task.\n\n### 21 - Unchanged State When Changing Task Type\n\nTests that a task\'s state field is retained when changing between task types. If a task dynamically changes its type, its state field should remain unaffected.\n\n# Obstacles\n\nNo software program is written bug-free on the first go around and ours was certainly not an exception. Thanks to our tracing systems and our test suites, we were able to find and resolve multiple bugs in our system. These ranged from simple mistake such as breaking out of a nested loop with continue rather than a goto statement to more serious bugs, such as creating infinite loops. Our implementation of the linked lists which held Task structures could, in some cases, produce cyclical lists that resulted in infinite loops and task not being terminated correctly. Along the same lines, one major bug we found was that a task that dynamically changed to an event-driven task type would never get put into the event-driven task list. This was a result of a missing condition in an if statement in our scheduler. Thankfully, we tested this case and found this bug. \n\nAnother interesting flaw we caught was relating to how we calculated the time remaining until a given task wanted to run next. Our initial calculation did not allow periodic tasks to run at time zero and, instead, calculated their first time remaining to be the length of their period plus their delay. To fix this, we added the first field to the Task_t structure to mark the first running of each task and set our scheduler to perform a slightly different calculation of time remaining on their first run.\n\nAlong with multiple implementation-specific bugs, there were a couple typical pitfalls that we came across while implementing our real time operating system. Thankfully, they were realized before major bugs were caused. These pitfalls included forgetting to declare certain variables as volatile, and forgetting to disable interrupts during certain critical sections. Both of these are common errors made in development of time-sensitive systems.',
        plainTxt: 'Author&#39;s Note\nThis blog post is part two in a series originally put together for the University of Victoria&#39;s CSC 460 course. The original content was publishd March 13 2019 by Torrey Randolph and myself. As that webpage no longer exists I am now hosting the content here.\nHere are links to part 1 and part 3.\n\nIntroduction\nThe goal of project 2 was to design and implement a real time operating system (RTOS) and a corresponding API to be used in the final project, project 3. The RTOS created for this project is an extension of a time-triggered architecture (TTA) scheduler, with some important new features including support for non-periodic tasks as well as multiple instances of the same task. Many design decisions had to be made including how to represent tasks, what scheduling algorithm to use, and how to keep track of time. These will be described in more detail in the sections below. This report will also cover the strategies used to test our implementation and some hardships we came across during the process.\nThe only special hardware needed for this project was a single Arduino Mega 2560 board and a Saleae USB logic analyzer. Software dependencies are the same as in project 1, they can be seen listed here.\nRTOS\nOverview\nThe simplicity of a TTA lends itself to a simple API, we wanted our RTOS keep this quality. TTA implementations are broken into two phases: a declarative phase, where tasks are defined for the scheduler, and a run phase, or runtime phase, where the scheduler manages the task. What makes our solution truly an RTOS and not just a scheduler is our emphasis on that runtime phase. This will become especially clear when we discuss our much more dynamic conception of tasks when compared to a standard TTA implementation. This focus also influenced our core API and what services we wanted to provide the user beyond simply calling a function at the right time, namely we built the RTOS from the ground up with instrumentation in mind and placed an emphasis on improving the debug experience of lower level C development. The following is a condensed overview of the RTOS API.\n```lang:c++-readonly\nnamespace RTOS {\nvoid init();\nvoid dispatch();\nvoid halt();\nvoid trace();\nvoid error();\nvoid debug_print(const char * fmt, ...);\nvoid debug_led(bool led);\n\nnamespace Registers {\n    extern Event_t triggers;\n}\n\nnamespace UDF {\n    void trace(Trace_t * trace);\n    bool error(Trace_t * trace);\n}\n}\n```\nThe functions init, dispatch, and halt are all essential to the basic operation of the RTOS, taking the responsibility of initializing resources, starting scheduling, and safely shutting down the RTOS respectively. We were selective about what C++ features we wanted to take advantage of for the RTOS, but namespaces were one we decided to capitalize on. Outside of simply helping avoid name collisions, namespaces serve our design to organize more traditional procedural programming constructs into something more familiar to programmers who have seen object oriented interfaces. \nThe functions trace and error allow both the internals of the RTOS, and user programs to efficiently communicate information with the developer. This could be scheduling information, debug messages, or runtime checks. How these functions works, along with their sister functions in the User Defined Function (UDF) namespace is detailed in the Tracing section of the report.\nOutside of these functions, the core functionality of the RTOS involves Tasks.\nTasks\nIn a standard TTA tasks are defined by an implementation, commonly a function, a period, and an offset. Our RTOS includes these properties and more in order to extend the functionality of a TTA. The comprehensive set of properties are viewable as the fields in the Task_t struct:\nlang:c++-readonly\nstruct Task_t {\n    task_fn_t fn;   // A pointer to the task funtion\n    void * state;   // A pointer to the task&#39;s associated state\n    Event_t events; // The events that cause this task to be scheduled\n    i16 period_ms;  // The schedule period of this task (in milliseconds)\n    i16 delay_ms;   // The delay before this task is scheduled\n    // &quot;hidden&quot; fields\n    struct {\n        bool first;\n        u8 instance; // Used to identify a task during a trace\n        i64 last;    // The last time this task was run\n        i16 maximum; // The maximum runtime of this task so far\n    } impl;\n};\nThe final three fields of the Task are meant to be used only by the RTOS for bookkeeping. The fields work as follows:\nfn: Like in TTA this defines the implementation, a function pointer that will run every time the task is scheduled. These functions are provided their containing Task_t struct as an argument allowing them to self modify and mutate. Additionally, we allow this function to determine whether the Task should be run again by returning a boolean result.\nstate: Providing room in Task_t for the user to store an arbitrary pointer allows for instancing of tasks. This is discussed in more detail later in the report.\nevents: We provide a mechanism for reactive computation by way of event-driven tasks. The events field of Task_t define what events a Task responds to.\nperiod_ms: The period is a standard field needed for a periodic TTA. Our RTOS provides accurate scheduling up to one ms.\ndelay_ms: Similar to period, delay is another standard field needed for TTA in order to offset Tasks from one another.\nfirst: Some behaviour of Tasks depends on whether it is being run for the first time. For instance a periodic time without delay will be run at time 0. \ninstance: In order to efficiently trace a Task schedule we want to be able to identify a Task by a unique identifier. We reserve one byte to indicate the Task instance. This is not referring to the type of instancing provided by the state field, this instance refers to every instance of Task that exists in the system.\nlast: This field records the last time this Task was run allowing the RTOS to easily calculate its next run time.\nmaximum: This field records the longest time this Task has ever taken to run. For standard periodic tasks this does not impact the Task&#39;s execution, but for less essential Tasks this gives the RTOS the ability to make a reasonable guess as to whether a Task can fit into an idle gap.\n\nA  key design decision in our RTOS is to represent all types of Tasks with a single construct. A Task is dispatched to the RTOS in two situations. First explicitly, when the user defines the task and then calls Task::dispatch. Second automatically, after a task is run it is reconsidered by the RTOS. This means that a task function can modify its associated Task_t struct in anyway it sees fit, allowing one type of task to become any other type of task. Additionally, tasks can be freely created and destroyed as the RTOS is running, simply by calling the appropriate functions from a task function.\nThis high level of dynamism means that the RTOS needs to support quick allocation and deallocation of Tasks as well as efficient means of bookkeeping different task types. Rather than depending on the heavyweight solution of malloc and free, we utilize a generic Memory Pool allocator (also sometimes referred to as a refrigerator allocator) to solve both of these problems. Memory Pool allocators can refer to slightly different systems depending on where you look. Our solution focuses on the allocation of like-sized memory chunks. We divide a region of memory into equal size chunks. Each chunk has enough room for the desired object and a pointer to another chunk. By chaining theses chunk pointers together we effectively create a linked list of available chunks. Figure 1 below helps illustrate this setup.\nMemory Pool Layout\nAllocating memory is as simple as popping the head off the list, and deallocating memory is as simple as prepending a chunk back on to the list. This allocation scheme is significantly simpler and faster than more generic allocation schemes, it also has a hidden benefit. When a chunk is allocated its associated chunk pointer is no longer being used by the allocator, this leaves it free to be used to help construct new linked list structures. This is the methodology used by the RTOS for task allocation and management.  Tasks are allocated using a Memory Pool, and then organized into linked lists using their associated chunk pointers.\nPeriodic Tasks\nPeriodic tasks are time-sensitive tasks that the RTOS aims to always run on time. The are the highest possible priority task. A periodic task is defined by its period and delay. The delay of a periodic task acts as its offset, determining how much time occurs between the task being created and being run. Dynamically created periodic tasks measure their start time from the scheduled time of the task that created them. The scheduled time of a task is the theoretically best time a task would run, not its actual time. This means that if there is a periodic task that dynamically creates another periodic task, that task will still run at the expected time.\nThe following is an example of creating a periodic task:\n```lang:c++-readonly\nusing namespace RTOS;\nTask_t * my_task = Task::init(&quot;my_task&quot;, my_task_fn);\nmy_task-&gt;period_ms = 1000;\nmy_task-&gt;delay_ms  = 500;\nTask::dispatch(my_task);\n```\nDelayed Tasks\nDelayed tasks are another form of time-sensitive tasks. Delayed tasks were added to the TTA to provide a clear method of declaring a &quot;one-shot&quot; task, ie. a task that is run only once. Our implementation of delayed tasks is more flexible however. A delayed task will be run jut once only if no new delay is supplied, or the task function itself returns false. This allows for a delayed task to be run an arbitrary number of times, waiting on a condition for instance, or run with different delays each time. \nDelayed tasks are created in the same manner as periodic tasks, only their period_ms field is left at 0. \nEvent Driven Tasks\nEvent driven tasks provide a way for our RTOS to respond to urgent events, such as an interrupt occurring.  Our RTOS allows interrupts to occur at most times, specifically interrupts can occur during the run time of any task as well as during idle time. This opens up our design to race-conditions. To avoid these painful issues we allow interrupts to only do two things: read arbitrary data and dispatch an event. There is no strict check to ensure that the user does not violate this rule, so it is on them to ensure their program upholds this convention. Event code is carefully written to allow read and writing from interrupts, disabling interrupts at key points in time if necessary.\nEvents in our system are represented as bits at a specific memory location. The definition for events is provided below:\n```lang:c++-readonly\ntypedef NUMTYPE_U(RTOS_MAX_EVENTS) Event_t;\nnamespace Event {\n    Event_t init(const char * handle);\n    void dispatch(Event_t e);\n}\n```\nThe number of bytes used for events depends on the desired maximum allowed events. We allow for 8, 16, 32, and 64 events corresponding to the different integer sizes. The Event API is limited to two functions, one for creating events and another for dispatching them. Internally the RTOS uses a variable to represent dispatched events. This variable is never read from or written to without first disabling interrupts.\nIn order for events to be useful tasks need to be able to respond to them. If a task has no delay and no period than it is allowed to become an event-driven task. A task sets its event field with the bits corresponding to the events it wants to listen to. When that even fires it will be scheduled in the next available idle gap, so long as no delayed task is waiting to run.\nEach event can only drive a single task, but a task can listen to multiple events. When an event-driven task is run a the RTOS::Registers::triggered variable stores what tasks triggered the task to run. After running the event is considered cleared and will not trigger the task again until the event is dispatched again.\nThe following is an example of creating an event-driven task that listens for two different events:\n```lang:cc++-readonly\nusing namespace RTOS;\nEvent_t event_1 = Event::init(&quot;event_1&quot;);\nEvent_t event_2 = Event::init(&quot;event_2&quot;);\nTask_t * my_task = Task::init(&quot;my_task&quot;, my_task_fn);\nmy_task-&gt;events = event_1 | event_2;\nTask::dispatch(my_task);\n```\nKeeping State\nIn a normal TTA, each run of a task is a new activation of that task; tasks have no way to keep track of their history, or their state. This also means that two tasks with the same task function will have the same effect. By providing a pointer for state on Task_t we allow tasks to maintain state and have a notion of different instances.\nKeeping Time\nTime is an important part of a real time operating system. The operating system has to have a concept of time, however that is implemented. Our RTOS uses a hardware timer set to interrupt every millisecond to keep track of the current time. This timer increments a global variable representing the time in milliseconds since the RTOS was dispatched. Two factors had to be considered while developing this system: the precision of the timer and the size of our variable.\nThe crystal oscillator on the ATMega2560 runs at 16 MHz. Hardware timers can be configured to use the CPU clock directly or to use a scaled version of that clock. We configured Timer/Counter 1 on the ATMega2560 to use a clock with one-64th the frequency of the CPU clock. This, along with its interrupt set to trigger when the counter reached 250, produced a timer interrupt that went off every one millisecond. One millisecond precision was found to be enough for our system, providing us decent precision while limiting the CPU time spent updating our global time variable.\nWhen deciding what size of variable to use, we calculated how long various sizes would take to overflow. Only signed integers were considered because the time is used in many arithmetic computations. With a 32-bit field, the largest number that can be represented is 2,147,483,647. That equates to 24 days of time-keeping before our variable would overflow. While that would be sufficient for the purposes of this project, we decided to instead use a signed 64-bit field, giving us roughly 292 years of time-keeping ability.\nScheduling\nThe RTOS scheduling procedure is where we achieve most of the desired functionality. The following is the source code for thee RTOS inner loop:\n```lang:c++-readonly\nvoid dispatch() {\nTime::init();\n\nMAIN_LOOP: for (;;) {\n\n    i64 this_time = Time::now();\n    i64 idle_time = 0xFFFF;\n\n    Task_t * task;\n\n    task = Registers::periodic_tasks;\n    if (task != nullptr) {\n        i64 time_remaining = Task::time_remaining(task, this_time);\n        if (time_remaining <= 0) {\n            // We need to pop the task off the list before running the task\n            // Run will handle re-inserting it correctly\n            Registers::periodic_tasks = Task::cdr(task);\n            Task::run(task);\n            goto MAIN_LOOP;\n        } else {\n            idle_time = min(idle_time, time_remaining);\n        }\n    }\n\n    task = Registers::delayed_tasks;\n    if (task != nullptr) {\n        i64 time_remaining = Task::time_remaining(task, this_time);\n        if (time_remaining <= 0) {\n            if (Task::fits(task, idle_time)) {\n                // We need to pop the task off the list before running \n                // the task. Run will handle re-inserting it correctly\n                Registers::delayed_tasks = Task::cdr(task);\n                Task::run(task);\n            }   \n            goto MAIN_LOOP;\n        } else {\n            idle_time = min(idle_time, time_remaining);\n        }\n    }\n    task = Registers::event_tasks;\n    if (Registers::events) {\n        while (task != nullptr) {\n            if (task->events & Registers::events) {\n                if (Task::fits(task, idle_time)) {\n                    Task::run(task);\n                }\n                goto MAIN_LOOP;\n            }\n            task = Task::cdr(task);\n        }\n    }\n    Time::idle(this_time, idle_time);\n}\n}\n```\nThe scheduling procedure is broken into four key steps. Scheduling periodic tasks, scheduling delayed tasks, scheduling event tasks, and idling. By maintaining our periodic and delayed tasks in sorted order, where the first task in the list is the next to run, we only have to check if the first task in each of these lists is ready to run. Task have a Task::time_remaining function which roughly return:\nmath\ntime remaining = (last time run + delay + period) - now\nThis means that a task is ready to run when its time remaining is equal to zero. We compare using less than or equal to for the case of a missed task. In reality this function is slightly more complex as periodic time begins at zero, and the notion of time remaining is not sensible for event-driven tasks.\nIf any task is successfully scheduled, or a task fails to fit within the remaining idle time, we immediately return to the start of the loop to ensure that our priority order is properly maintained. A task can fit if its maximum time is less than the current idle time. When first running a task our RTOS is naively optimistic, assuming the task will take zero milliseconds, but each run the maximum time is updated, and if that task does not fit in the idle time it will be skipped.\nWhen periodic or delayed tasks are run, they are removed from their respective lists, moving the next to run task to the top. They will be reinserted in sorted order by Task::run if necessary.  The same goes for adding event tasks that dynamically change to and from other task types. Note that because event tasks are prioritized first come first serve, we have to iterate over the entire event list in order to check if one needs to be scheduled. \nIf no task can currently run we idle until the next time sensitive task is ready to run. This is done using the following function:\n```lang:c++-readonly\nvoid idle_mode() {\n    set_sleep_mode(SLEEP_MODE_IDLE);\n    sleep_mode();\n}\nvoid idle(i64 this_time, i64 idle_time) {\n    // Get most accurate idle time\n    i64 now_time = now();\n    idle_time -= (now_time - this_time);\n// Check if time has already passed by now\nif (idle_time < 1) {\n    return;\n}\n\n// Delay\nwhile(now() - now_time < idle_time && !Registers::events) {\n    idle_mode();\n}\n}\n```\nDuring idle time we put the CPU into Idle Mode using the appropriate AVR Libc functions. This helps reduce power consumption. Because we keep time using an interrupt, we are guaranteed to idle for no more than one millisecond at a time. When we wake up we check whether the appropriate amount of time has passed or if an event has gone off, in which case we return to the scheduler.\nIf a task misses its scheduled time, an error is traced, however the task will maintain the schedule it would have had should it not have been missed. For instance if a task is expected to run every 1000 ms, runs for the first time at 2000 ms, but misses its second run, running instead at 3001 ms, it will still be scheduled for 4000 ms, not 4001 ms. This makes the RTOS scheduling much easier to predict even when some tasks experience slight jitter.\nTracing\nTracing occurs throughout the RTOS. Anytime a Task is created, started, or stopped, memory is allocated, the CPU is put into idle mode, all of these actions and more are traced. Tracing is done by updating a trace struct with appropriate values and then issuing a call to trace. This will call the UDF of the same name. It is up to the user programmer to decide what to do with tracing information. Additionally, we allow the user programmer to opt out of tracing using preprocessor directives allowing the RTOS to run without the overhead of tracing. The actions captured by tracing are best summarized by looking at the tagged union used to represent the data:\n```lang:c++-readonly\nenum Trace_Tag_t {\n    // Definitions\n    Def_Task,  // The creation of a task\n    Def_Event, // The definition of an event\n    Def_Alloc, // The allocation of memory\n    // Marks\n    Mark_Init,  // The start of the RTOS\n    Mark_Halt,  // RTOS exucution is about to stop\n    Mark_Start, // The start of a task\n    Mark_Stop,  // The end of a task\n    Mark_Event, // The occurence of an event\n    Mark_Idle,  // Scheduled idle time\n    Mark_Wake,  // Woke up from idle time\n    // Errors\n    Error_Max_Event,       // Maximum number of events exceeded\n    Error_Undefined_Event, // Undefined event dispatched\n    Error_Max_Alloc,       // Maximum memory allocation exceeded\n    Error_Max_Pool,        // Maximum pool allocation exceeded\n    Error_Null_Pool,       // Null pool or chunk pointer passed as argument\n    Error_Max_Task,        // Maximum tasks exceeded\n    Error_Null_Task,       // Null task passed as argument\n    Error_Invalid_Task,    // Invalid task configuration provided\n    Error_Duplicate_Event, // Two tasks act on the same event\n    Error_Missed,          // A task schedule was missed\n    // Debug\n    Debug_Message, // Used to send messages to the tracer\n};\ntypedef struct Trace_t Trace_t;\nstruct Trace_t {\n    Trace_Tag_t tag; // The trace tag\n    union {\n        union {\n            struct { const char * handle; };\n            struct { const char * handle; u8 instance; } task;\n            struct { const char * handle; Event_t event; } event;\n            struct { const char * handle; u16 bytes; } alloc;\n        } def;\n        union {\n            struct { u64 time; };\n            struct { u64 time; u16 heap; } init;\n            struct { u64 time; } halt;\n            struct { u64 time; u8 instance; } start;\n            struct { u64 time; u8 instance; } stop;\n            struct { u64 time; Event_t event; } event;\n            struct { u64 time; } idle;\n            struct { u64 time; } wake;\n        } mark;\n        union {\n            struct { Event_t event; } undefined_event;\n            struct { Event_t event; } duplicate_event;\n            struct { u8 instance; } invalid_task;\n            struct { u8 instance; } missed;\n        } error;\n        union {\n            struct { const char * message; };\n        } debug;\n    };\n};\n```\nThe Trace tags vary in purpose from scheduling information to runtime error checking. Definition traces, for when a user programmer defines a Task, Event, or allocates memory also provides a human readable handle which can be useful for visualizing trace results. We use a tagged union to try and minimize the overall memory footprint of Traces. The precise size of a Trace will vary between 12 and 18 bytes depending on the specified number of Events the user needs.\nError traces are provided to the user programmer even when normal tracing is disabled. These correspond to various unexpected events, such as running out of memory, or a task missing its scheduled time. It is up to the user program to decide how to react to these errors. The UDF error function is passed these traces, if it returns true the RTOS will continue execution, otherwise it will halt immediately. This allows programs to react in different ways to different error states. For instance some programs may wish to crash if a specific task is missed, but not crash for others. This system allows for that level of fine grained control.\nThe RTOS provides two built in methods of handling traces, pin tracing and serial tracing. With pin tracing the function Trace::configure_pin can be used to assign digital pins to specific tasks. If the UDF provides all traces to Trace::pin_trace, the RTOS will automatically set the appropriate digital pins high and low as tasks run. This makes integration with a logic analyzer trivial. \nSerial tracing will output the trace bytes directly to a serial port. We wrote a small python module that could decode the trace and keep a log. This module would print the trace in a JSON format to stdout as well as print RTOS debug messages to stderr. We combined this functionality with a small web server that served these logs and a small webpage for visualizing the results. To provide an idea of how this works, here is the logic analyzer results for one of our tests, compared to the visualized results from our python module:\nlogic 1\nwebpage visualization\nIn addition to plotting the trace of tasks we also used the webpage to display additional information, such as RTOS memory usage, and general statistics about CPU utilization and task times. This interface provides a sort of real time dashboard for the board, as the webpage can be updated as the board runs and traces arrive on the serial port. This became an indispensable tool during development.\nTesting\nOverview\nTime-sensitive applications are notoriously hard to test, let alone the RTOS running underneath them. However, to ensure that everything is working properly, testing is necessary. One popular way to test real-time systems is by having the system produce a trace of what is going on so that the user can visually analyze the results. To make sure the system behaves correctly and will not produce unintended results, developers try to force the system to exhibit bad behaviour. If the system has been implemented correctly, it will deal with these situations as predicted and produce an expected trace.\nTime-insensitive features or components of a software program can be tested without producing a trace and instead by writing unit tests. The unit tests described below used software assertions to verify expected behaviour of each component.\nFor any time-sensitive features, schedule tests were created to use traces produced by our RTOS to verify correct behaviour.  These tests can be set up to use any of the tracing methods described above as a verification method, as well as additional software assertions. The twenty-one schedule test cases below were ran multiple times during development to ensure systems were not broken in the process and that everything worked as expected after code was finalized.\nUnit Tests\nEvent Tasks\nTests a number of functions involving events. Creates and asserts the uniqueness of events, tests dispatching them and ensuring and global variables for the RTOS are updated correctly. Tests that all of these actions produce correct traces. Also tests that error traces will occur if too many events are created, or an undefined event is dispatched.\nMemory Tests\nTests the static and pool allocators provided by the RTOS.  The static allocator simply provides one time dynamic memory allocation without any ability to free memory. Pool allocators are tested to see if they provide usable, safe memory, and can be combined into lists and deallocated. All of these steps are checked for correct traces, and in the case of either the static allocator or pool allocator running out of memory, an error trace is expected.\nTask Tests\nTests the creation of tasks, and ensues that RTOS global variables are updated correctly when tasks are dispatched. For instance periodic tasks are dispatched and their order is checked to ensure that the RTOS correctly sorts them. Event tasks are also tested to ensure that they appear in FIFO order and will create an error trace when two tasks attempt to listen to the same event.\nScheduling Tests\n01 - Single Periodic Task\nTests that a periodic task runs repeatedly and on time.\n02 - Multiple Periodic Tasks\nTests that two alternating periodic tasks run in the correct order and at the correct times.\n03 - Single Periodic Task with Offset\nTests that a periodic task with an initial delay runs at the correct times. For example, a task with a period of 500 milliseconds and an initial delay of 200 milliseconds should run at the following times: 200 ms, 700 ms, 1200 ms, 1700 ms, etc.\n04 - Overlapping Periodic Tasks\nTests that two periodic tasks scheduled to overlap each other will cause the second task to miss its deadline and an Error_Missed error to be sent to the user.\n05 - Defining Tasks in the Wrong Order\nTests that the scheduler schedules tasks in the correct order regardless of the order they were dispatched in. Two periodic tasks were created, each with a period of 500 milliseconds. One of the tasks, Task 2, also had an initial delay of 250 milliseconds. Though Task 2 was dispatched to the operating system before Task 1, the scheduler correctly ran Task 1 before Task 2.\n06 - Instances of a Single Task\nTests that two instances of a single task retain their separate states correctly. Two periodic tasks were created; Task 1&#39;s state field was assigned the value of true and Task 2&#39;s was assigned the value of false. Every time the task function was ran, depending on the instance of the task currently being executed, it asserted that the state field was true or false as expected. This demonstrated that two tasks sharing the same task function have separate states.\n07 - Event Occurring Prior to OS Dispatch\nTests that the operating system is able to remember events that may occur between the time that the operating system is initialized and dispatched.\n08 - Terminating Delayed Task\nTests that a single delayed task is run once at the correct time and then never run again.\n09 - Terminating Immediate Task\nTests that a single immediate task (a delayed task with delay_ms of zero) is ran once and then never run again.\n10 - Repeating Delayed Task\nTests that a single delayed task that creates itself is put back in the queue and ran again at the correct time.\n11 - Interrupt During Periodic Task\nTests that a periodic task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the periodic task completes. Furthermore, the periodic task is run at its next scheduled period.\n12 - Interrupt During Delayed Task\nTests that a delayed task is allowed to finish execution after an interrupt goes off in the middle of it. The corresponding event-driven task is run after the delayed task completes.\n13 - A Long Task in a Short Idle Time\nTests the scheduler&#39;s ability to determine if a task will fit in a given idle time. In this test, a periodic task was created and schedule to run for 40 milliseconds every 500 milliseconds. An event-driven task was created and set to run for 500 milliseconds when triggered. Below, Figure 2 shows the correct sequence of events that occurred. At timing marker A1 the periodic task executed for 40 milliseconds. During that time, a timer interrupt went off, triggering the event. The periodic task completed its execution and then event-driven task ran for 500 milliseconds. When the event-driven task completed, the time was roughly 540. Though the periodic task was supposed to run at time 500, it missed its deadline due to the length of the event-driven task. The operating system will have noted the running time of the event-driven task and at the start of the next idle time, even though the event is triggered again, the scheduler correctly determines that it does not have time to run the event-driven task.\nlogic 2\n14 - Multiple Interrupts in a Long Idle Time\nTests that an event-driven task runs multiple times during a single idle period if the event is triggered multiple times and the task fits within the time constraint.\n15 - Periodic Task Becoming Delayed\nTests that a periodic task can dynamically become a delayed task. A periodic task may set its period_ms field to zero and its delay_ms field to non-zero to transform from a periodic task to a delayed task.\n16 - Delayed Task Becoming Periodic\nTests that a delayed task can dynamically become a periodic task. A delayed task may set its period_ms field to non-zero to transform from a delayed task to ta periodic task. \n17 - Periodic Task Becoming Event-Driven\nTests that a periodic task can dynamically become an event-driven task. A periodic task may set its period_ms field to zero and its events field to the desired event(s) to transform from a periodic task to an event-driven task.\n18 - Event-Driven Task Becoming Delayed\nTests that an event-driven task can dynamically become a delayed task. An event-driven task may set its events field to zero and its delay_ms field to non-zero to transform from an event-driven task to a delayed task.\n19 - Delayed Task Becoming Event-Driven\nTests that a delayed task can dynamically become an event-driven task. A delayed task may set its events field to the desired event(s) to transform from a delayed task to an event-driven task.\n20 - Event-Driven Task Becoming Periodic\nTests that an event-driven task can dynamically become a periodic task. An event-driven task may set its events field to zero and its period_ms field to non-zero to transform from an event-driven task to a periodic task.\n21 - Unchanged State When Changing Task Type\nTests that a task&#39;s state field is retained when changing between task types. If a task dynamically changes its type, its state field should remain unaffected.\nObstacles\nNo software program is written bug-free on the first go around and ours was certainly not an exception. Thanks to our tracing systems and our test suites, we were able to find and resolve multiple bugs in our system. These ranged from simple mistake such as breaking out of a nested loop with continue rather than a goto statement to more serious bugs, such as creating infinite loops. Our implementation of the linked lists which held Task structures could, in some cases, produce cyclical lists that resulted in infinite loops and task not being terminated correctly. Along the same lines, one major bug we found was that a task that dynamically changed to an event-driven task type would never get put into the event-driven task list. This was a result of a missing condition in an if statement in our scheduler. Thankfully, we tested this case and found this bug. \nAnother interesting flaw we caught was relating to how we calculated the time remaining until a given task wanted to run next. Our initial calculation did not allow periodic tasks to run at time zero and, instead, calculated their first time remaining to be the length of their period plus their delay. To fix this, we added the first field to the Task_t structure to mark the first running of each task and set our scheduler to perform a slightly different calculation of time remaining on their first run.\nAlong with multiple implementation-specific bugs, there were a couple typical pitfalls that we came across while implementing our real time operating system. Thankfully, they were realized before major bugs were caused. These pitfalls included forgetting to declare certain variables as volatile, and forgetting to disable interrupts during certain critical sections. Both of these are common errors made in development of time-sensitive systems.\n',
        route: '/blog/rtos2',
        layout: '../../layouts/Blog',
        title: 'Creating an RTOS (Pt. 2)',
        subtitle: 'Designing and implementing a RTOS based on a Time Triggered Architecture',
        blog: true,
        date: '05-19-2019',
    }),
    rtos3: new Page({
        name: 'rtos3',
        content: '> # Author\'s Note\n>\n> *This blog post is part three in a series originally put together for the University of Victoria\'s CSC 460 course. The original content was publishd April 7 2019 by [Torrey Randolph](https://github.com/torreyr) and myself. As that webpage no longer exists I am now hosting the content here.*\n>\n> *Here are links to [part 1](/blog/rtos1) and [part 2](/blog/rtos2).*\n\n# Introduction\n\nAs our final project in CSC 460 we created a semi-autonomous, remote controlled, Roomba. This project is the culmination of the lessons we learned in Project 1, where we interfaced with many of the same pieces of hardware, and Project 2, where we developed an RTOS to assist us in this project. \n\nThe Project 3 Roomba has a number of features which we needed to develop in order to compete in a final tournament between teams of similarly constructed robots. Our Roombas would attempt to defend "castle" structures whilst also doing battle with other Roombas. To achieve this goal we needed to provide the ability to:\n\n - drive the Roomba using a joystick,\n - aim and fire a laser,\n - detect when we are shot by another Roomba\'s laser.\n\nIn addition to these features we also provide a couple of semi-autonomous features based off the project description [1], namely the ability to detect walls and infrared (IR) beams. These deliverables were split into two phases. A first phase focuses on the human-controlled features, as well as the Roomba\'s ability to respond to being hit with a laser. The second phase focuses on the semi-autonomous features.\n\nTo help organize, debug, and manage this project we make use of the RTOS we developed in Project 2. This RTOS is based on a Time Triggered Architecture (TTA) and, as such, our design is segmented into a series of tasks run on two Arduino boards, one attached directly to a Roomba and the second attached to a dual analog stick controller.\n\n## Software Dependencies\n\nWe took advantage of the software ecosystems provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\n\n - [VS Code](https://code.visualstudio.com/): Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\n - [AVR Toolchain](https://www.nongnu.org/avr-libc/): In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR microcontrollers. AVR Libc is the backbone of the Arduino libraries. The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\n - [Mekpie](https://ejrbuss.net/mekpie/): Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \n - [Saleae Logic](https://www.saleae.com/): This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\n\nIn terms of code samples we also made use of Roomba code made available on Neil\'s Log Book [2]. This code was invaluable in our interfacing with the Roomba.\n\n## Hardware\n\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\n\n - [Create 2 Programmable Roomba](https://www.irobot.com/about-irobot/stem/create-2): The Roomba was interfaced and controlled via one of our Arduino boards.\n - [2x Arduino Mega 2560 boards](https://store.arduino.cc/usa/arduino-mega-2560-rev3): One board was used to directly interface with the Roomba, while the other was used to create a controller.\n - [2x SG-90 Micro Servos in a pan and tilt module](http://www.ee.ic.ac.uk/pcheung/teaching/DE1_EE/stores/sg90_datasheet.pdf): These two servos were used to aim a mounted laser.\n - [2x HC-06 Bluetooth modules](http://wiki.sunfounder.cc/index.php?title=Bluetooth_Transceiver_Module_HC-06): These two Bluetooth modules were used to communicate between the Roomba and the controller in phase 2.\n - [2x Arduino KY-023 Joystick](https://tkkrlab.nl/wiki/Arduino_KY-023_XY-axis_joystick_module): One analog joystick was used to control the movement of the Roomba. The second controlled the motion of the pan and tilt module. One of the joystick buttons was also hooked up to the laser.\n - [Robojax Red Laser](https://www.amazon.ca/Robojax-650nm-Laser-Module-Arduino/dp/B07CTTW1VR/ref=asc_df_B07CTTW1VR/?tag=googleshopc0c-20&linkCode=df0&hvadid=293019993829&hvpos=1o2&hvnetw=g&hvrand=531459062635060218&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9001595&hvtargid=pla-640824366184&psc=1): This laser was used to shoot at other Roombas.\n - [Light Sensor Module](https://it.aliexpress.com/item/10pcs-lot-light-sensor-module-for-Arduino-digital-switch-sensors-High-precision-of-the-photocell/1944430271.html): This was used to detect a laser hit.\n\n# Phase 1\n\nIn phase 1 we designed and implemented the features to control our Roomba. This mainly consisted of controlling the Roomba\'s movement using a joystick. Movement worked in two ways depending on the mode. In the first mode, which we called Move Mode, the Roomba can move forward, backwards, and turn on the spot, essentially free to move in whatever way the driver desires. In the second mode, which we called Still Mode, the Roomba can rotate on the spot, but cannot move forwards or backwards. The Roomba then switches between these two modes every 30 seconds as per the project specifications. This design is meant to make hitting other Roombas with a laser feasible during the tournament.\n\nIn addition to controlling the Roomba movement, a laser, mounted on a pan and tilt module, must also be controllable via a joystick. This will allow the Roomba to "attack" other Roombas by aiming its laser at their light detector. In addition, to make our Roomba "killable", we needed to provide an omnidirectional light detector that "kills" our Roomba after two continuous seconds of a laser hit. A kill results in our Roomba no longer responding to controller input and remaining still.\n\n## Design\n\nOur design is implemented in two separate programs, one for the controller, and one for the Roomba. These two programs communicate via Bluetooth. We adapted the same messaging system as in Project 1. In this system the controller program sends the Roomba program packets containing the joystick positions and button statuses. The packet is preceded by a four byte header, which is used to synchronize the packet transmissions. New in Project 3, we introduced two-way communication by having the Roomba program send debug information back over Bluetooth. This allowed us to see debug information on a serial monitor from both programs when running. Additionally, the tracing system provided by our RTOS was usable with both programs, allowing us to easily see a trace of our tasks running, without having to plug in a logic analyzer. \n\n### Controller\n\nFor the controller program, our design has two tasks: one for sampling inputs from the controller, and one for forwarding Bluetooth messages from the board over USB to the computer so that they could be seen on a serial monitor. Sampling input from the controller would run every 150 ms. We adjusted this value multiple times during development, but found that periods less than this did not offer much of an advantage, and produced more Bluetooth-related errors. The task that forwards Bluetooth messages had to be set to a much higher period to ensure the Bluetooth buffer did not overflow. We settled on a 30 ms period. These tasks produce the following trace:\n\n![controller task trace](/static/blog/rtos3/controller-task-trace.png)\n\nIn terms of hardware, the controller would need to connect to two analog joysticks and a Bluetooth chip. The wiring design for the controller is shown below:\n\n![controller block diagram](/static/blog/rtos3/controller-block.jpg)\n\nOur design is simple from a hardware perspective, and so some sampling tasks are up to software, namely we needed to provide a low pass filter for the analog sticks in order to reduce noise, and debounce the analog stick buttons. Power for our design could come straight from a laptop as the controller could remain with the user.\n\n### Roomba\n\nFor the Roomba program, our design has three tasks: one for retrieving sensor data from the Roomba, one for switching modes, and one for controlling the Roomba, servo motors, and other peripherals. The first task, retrieving sensor data, relates to phase 2, and is discussed in more detail in that section. This task would run every 120 ms. The mode switch task would run every 30 seconds, providing an easy way to reliably switch modes without having to use an extra timer. The control task would run every 60 ms, much faster than the controller\'s sample task. From project 1 we learned the importance of reading Bluetooth much faster than writing to it. The control task receives messages from Bluetooth, changes the Roomba\'s current velocity and turning radius, adjusts the pan and tilt servos, and activates/deactivates the laser. These tasks produce the following trace:\n\n![roomba task trace](/static/blog/rtos3/roomba-task-trace.png)\n\nThe hardware for the Roomba is somewhat more complex than for the controller. The Roomba program would run on an Arduino board powered by the Roomba\'s battery. The board connects to, and powers, a photoresistor, Bluetooth chip, and laser. Additionally, a pan and tilt servo module is powered separately using a power adapter and a second power connector from the Roomba. The power adapter was needed to turn the 16 V provided by the Roomba to the 5 V needed for the servo motors.  Finally, in order to control the Roomba, we connected to its 7-pin port which provided us, in addition to power and ground, UART serial lines and a line used to tell the Roomba what baud rate we wanted to use. The wiring design for the Roomba is shown below:\n\n![roomba block diagram](/static/blog/rtos3/roomba-block.jpg)\n\nIn addition to the features already mentioned, our design would also have to detect a photocell laser hit that lasted two seconds, and prevent the laser from being fired for more than an accumulated ten seconds. We included functions for these features in the control task. More detail will be provided below.\n\n## Implementation\n\nThe controller and Roomba program implementations are largely unique programs, each having to drive unique hardware. However, they did share RTOS and messaging code. We wrote both programs concurrently, testing features one at a time. In rare cases we would create tests that relied on only one of the programs, which simplified some difficult problems.\n\n### Controller\n\nWhen constructing the controller, we used a combination of a cardboard base, electrical tape, and twist ties to secure our hardware components. This resulted in a relatively comfortable to use dual analog controller, pictured below:\n\n![controller](/static/blog/rtos3/controller.jpg)\n\nIn our design, the Bluetooth forwarding task is only used for debugging. As such, our sample task can be looked at as the main loop for our controller. In it we start by sampling the x and y values from both joysticks, and then check whether one of the stick\'s button has been pressed. Next we write all of this data to the Bluetooth serial port. Note that this data is wrapped in a Message struct which has an unchanging 4-byte header preceding the data. In order to provide a properly initialized Message struct we took advantage of the task\'s state pointer to pass in an initialized Message from our main function. The code for the sample task is shown below:\n\n```lang:c++-readonly\nbool task_sample_fn(Task_t * task) {\n    Message_t * current_message = (Message_t *) task->state;\n    current_message->u_x   = Stick::x(stick_u);\n    current_message->u_y   = Stick::y(stick_u);\n    current_message->m_x   = Stick::x(stick_m);\n    current_message->m_y   = Stick::y(stick_m);\n    current_message->flags = Stick::sw(stick_m) ? MESSAGE_LASER : 0;\n    // send the message\n    u8 * buffer = (u8 *) current_message;\n    u16 i;\n    for (i = 0; i < sizeof(Message_t); i++) {\n        bluetooth->write(buffer[i]);\n    }\n    task->state = (void *) current_message;\n    return true;\n}\n```\n\n### Roomba\n\nThe Roomba hardware components were attached directly to a raised platform on top of the Roomba. Most of these components were attached via electrical tape. A red cup was used to make the photocell omnidirectional. The final assembly is pictured below:\n\n![roomba](/static/blog/rtos3/roomba.jpg)\n\nFor the Roomba code, we borrowed heavily from code and advice found on Neil\'s Log Book [2]. The code and explanations provided there made interfacing with the Roomba a relatively painless ordeal. \n\nIn terms of core functionality, we had the previously mentioned tasks for switching modes and control. For switching modes our task would toggle a boolean stored by our Roomba file as well as play a one note song to provide an audio indication to the driver that the Roomba had switched modes. Additionally, we included optional print messages for debugging over Bluetooth. The code for the mode switch task is shown below:\n\n```lang:c++-readonly\nbool task_mode_switch_fn(Task_t * task) {\n    if (Roomba::state == Roomba::Move_State) {\n        override_control = false;\n        Roomba::state = Roomba::Still_State;\n        Roomba::play_song(Roomba::Still_Song);\n        #ifdef PRINT_STATE\n            debug_print("Roomba::state = Still_State\\n");\n        #endif\n    } else {\n        override_control = false;\n        Roomba::state = Roomba::Move_State;\n        Roomba::play_song(Roomba::Move_Song);\n        #ifdef PRINT_STATE\n            debug_print("Roomba::state = Move_State\\n");\n        #endif\n    }\n    return true;\n}\n```\n\nFor Roomba movement, we tried a number of designs. In the end we found that simpler was better. Roomba movement is governed by two parameters, radius and velocity. The Roomba can be thought of as always driving in a circle; to go straight one just needs to drive in a circle with a near infinite radius. By default we set radius to the maximum possible value. We then check if x is non-zero and if so we set the turn radius to the smallest possible value. This would effectively cause the Roomba to turn on a dime. If the Roomba is told to turn we provide it a base turn speed. In Still Mode this is the complete process. If we are in Move Mode, however, we check to see if the user has moved the stick farther in the y direction than the x direction. If so, we set the radius back to the maximum and scale the Roomba\'s velocity based on how far forward the stick is being held. The code for the Roomba movement is shown below:\n\n```lang:c++-readonly\n\ni16 radius = MAX_TURN_RADIUS;\nif (x > 0) {\n    radius = 1;\n} else if (x < 0) {\n    radius = -1;\n}\ni16 velocity = x == 0 ? 0 : TURN_SPEED;\nif (state == Move_State && abs(y) > abs(x)) {\n    radius   = MAX_TURN_RADIUS;\n    velocity = (((i32) y) * MAX_SPEED) / 127;\n    if (x != 0) {\n        if (velocity > 0) {\n            velocity = clamp(velocity, TURN_SPEED, MAX_SPEED);\n        } else {\n            velocity = clamp(velocity, -MAX_SPEED, -TURN_SPEED);\n        }\n    }\n}\n```\n\nFor the photocell and laser we needed to keep track of time. This proved relatively simple as our RTOS provides a function for getting the current time in milliseconds. We simply tracked how long the photocell had been hit, and how long the laser had been on in two respective functions, and when they exceeded the maximum, took the appropriate action. For the laser that meant disabling further laser activations. For the photocell that meant stopping control and playing a short song to indicate that the Roomba had been "killed".\n\n## Drawbacks and Obstacles\n\nWe faced a number of obstacles while developing phase 1. A major problem was with our omnidirectional photocell not detecting a laser hit. We found that the light noise in the room was producing more change in our analog photocell than shining the laser on the cup was. We tried a number of fixes, including changing resistors in our voltage divider many times, trying a new photocell, and then switching to a digital photocell. The digital photocell proved much easier to work with, but suffered the same core problem that the laser simply was not producing enough light. The solution was to switch to a stronger laser. Once we realized this, detecting the laser hit became much easier.\n\nThe other core obstacle we faced during phase 1 was jerkiness and power issues with our servo motors. Our servos would twitch occasionally when powered, and we were unsure if this was a power issue or if our PWM signal was inconsistent. We looked at the signal using a logic analyzer and found that we did have some variation in the duty cycles sent to the servos, but were unconvinced that the variations were enough to cause the problems. The larger issue, however, was that, after about half a minute of the servos being on, our board would start to power cycle repeatedly, meaning we would lose Bluetooth connection and no longer be able to control our Roomba. We were unable to resolve this issue, and in the end went into the tournament without a working servo, instead relying on the Roomba movement to aim our laser.\n\nOutside of these issues we had a couple of problems due to a bug in our RTOS regarding scheduling more than two periodic tasks. This was a test case we missed during Project 2. As soon as we determined that this was the problem, it was a relatively easy fix.\n\n# Phase 2\n\nPhase 2 of Project 3 was to implement simple semi-autonomous behaviours for our Roomba. This included two key behaviours: backing up when hitting a wall, and backing up when hitting an IR signal, or "virtual wall". These behaviours could be achieved using sensors built-in to the Roomba, namely a front bumper and a front-mounted omnidirectional IR sensor. Overall this phase was far simpler than phase 1. However, we did have to modify our control design slightly, in that we needed to introduce a new "override state". When in this state, driver control input would be ignored, and instead the semi-autonomous behaviour, in this case driving backwards, would be performed. This state change could be managed in a similar manner to how we handled timing in phase 1 for the laser and photocell.\n\nWe also opted to have these behaviours receive a lower precedence than the Roomba\'s mode, ie. if the Roomba entered Still Mode and the IR sensor was activated, the Roomba would not be allowed to backup. This was achieved by having the mode switch function always exit the override state if it was enabled and ignoring sensor input during Still Mode.\n\n## Implementation\n\nWe created a new task that ran every 120 ms that polled sensor data from the Roomba. A two-state system was used; when the task was in the request state it sent four bytes over the Roomba UART connection, requesting the sensor data for the bumper and IR sensor. When the task is run again it is in the receive state, which will only read the data once two bytes have buffered in the Roomba UART connection. After this, the task switches back to the request state. The state diagram below illustrates this system.\n\n![state diagram](/static/blog/rtos3/state-diagram.png)\n\nThis state system is used to prevent the task from blocking, as the time it takes for the Roomba to respond to sensor data requests has some unwanted latency. Initially, this task was given a far longer period, which resulted in the sensor data we polled not picking up on short activations, such as a quick tap of the bumper. The implementation of the sensor reading is provided below.\n\n```lang:c++-readonly\nvoid update() {\n    static bool waiting_for_data = false;\n    if (!waiting_for_data) {\n        roomba_serial->write(SENSORS);\n        roomba_serial->write(SENSOR_IR);\n        roomba_serial->write(SENSORS);\n        roomba_serial->write(SENSOR_BUMPER);\n        waiting_for_data = true;\n    } else if (roomba_serial->available() >= 2) {\n        ir     = roomba_serial->read() ? true : false;\n        bumper = roomba_serial->read() & 0b11 ? true : false;\n        waiting_for_data = false;\n    }\n}\n```\n\n## Drawbacks and Obstacles\n\nThe sensor system worked largely without problems. One issue with the state system, however, was that if Bluetooth cut out during a semi-autonomous behaviour the Roomba would continue to move backwards even after the override state had ended. A timeout on controller packets could have been used to resolve this issue, setting the Roomba speed to a reasonable default, like zero. However, we figured that if our Bluetooth cut out, we would have bigger problems than just the override state.\n\nA design drawback of our solution is that if our Roomba were to back into an IR beam, it would backup through it, effectively crossing any existing IR barrier. We decided this was an acceptable limitation, however there were a number of solutions we considered developing:\n\n - Consider the Roomba\'s current direction and attempt to go in the opposite direction.\n - Rather than having the Roomba back up, simply have it turn 180 degrees to face the opposite direction.\n - Prevent the Roomba from moving backwards at any time.\n\nAll of these solutions had problems, however, such as the 180 degree turn solution resulting in the Roomba getting itself trapped in a cycle of constantly rotating. This occurred during the final tournament to a couple other Roombas that implemented this solution. In the end we believe our simple solution was effective.\n\n# Testing and the Tournament\n\nOur Roomba competed in a tournament that pitted it against Roombas with similar features. During the tournament, teams of two Roombas competed in a game of attack and defense. An arena was set up with two lanes, divided by an IR river, as well as two "castles" at one end. If shot by a laser these castles would be destroyed, resulting in a win for the attackers. One attacking Roomba and one defending Roomba was placed on each side of the river creating a 1v1 environment. Additionally, Roombas were outfitted with a "shield" which could be used to protect themselves and their castle, as well as using it to deflect attacks back at the enemy.\n\nBefore competing in the tournament we spent much of our time testing our Roomba features and gathering some metrics on its memory and CPU utilization.\n\n## Testing Process\n\nDuring development we tested features one at a time. An essential part of the process was our use of debug messages. By forwarding messages over Bluetooth we could use the serial monitor to view information from either program while testing. For example. we could easily see what our sensor values were during phase 2, or what we thought we were setting our Roomba velocity and radius to during phase 1.\n\nThe RTOS traces were also useful for ensuring our tasks were running at the correct times and that no task was running over time. For hardware problems however, the logic analyzer still proved to be an invaluable tool.\n\n## Tournament Performance\n\nDuring the tournament we placed second. Being unable to use the servo to aim our laser was not a major disadvantage. The chaos of the tournament meant that only having to worry about aiming using our Roomba made the task of control simpler, and, focusing only on killing other Roombas, we did not have to worry about the angle of our laser. Using this technique we were able to score a kill in the first game.\n\nDuring the tournament we did experience some Bluetooth buffering problems. This caused our Roomba to begin to twitch after a minute or so. Thankfully, this problem could be fixed by resetting the controller, resulting in only a few moments without direct control. \n\nThe tournament itself was generally chaotic, and once Roombas were out of lasers to fire the best strategy seemed to be to try and ram the enemy Roomba into the IR river.\n\n## Other Metrics\n\nWe were also able to collect data on our memory usage and CPU utilization using our RTOS. The pie charts presented here relate to our RTOS heap, not the C heap. This heap is used by our RTOS\'s custom allocator. Overall, memory was not much of an issue, and the main consumer of memory was our task pool, which could easily have been smaller as we only needed two tasks for the controller and three tasks for the Roomba, but had enough memory for up to sixty-four tasks. Otherwise, only a small amount of memory was used for structs that kept track of tuning parameters and state for hardware. The graphs below show the memory breakdown.\n\n![memory usage](/static/blog/rtos3/controller-memory-usage.png)\n\n![memory usage](/static/blog/rtos3/roomba-memory-usage.png)\n\nAccording to our RTOS tracer our CPU utilization was extremely low, 0.6% for the controller, and 0.1% for the Roomba. These measurements are likely inaccurate due to the lack of resolution less than 1 ms. Our CPU utilization is still likely very efficient, however, as no task took more than 1 ms to run, meaning that most of our time was spent with the CPU in idle mode. These CPU metrics for both programs are shown below:\n\n![controller cpu utilization](/static/blog/rtos3/controller-cpu.png)\n\n![controller cpu utilization](/static/blog/rtos3/roomba-cpu.png)\n\n# Conclusion\n\nProject 3 was an overall success despite our issues with the servos. All of our other features worked effectively. Our Roomba managed to perform well during the tournament and did not go overboard on CPU utilization. We learned a lot during this process and faced many setbacks during the development process. At least for us, the hardware generally proved more difficult than the software, though both had their fair share of challenges. This is likely just a matter of experience as neither of our team members have extensive experience with hardware.\n\nOur RTOS from Project 2 proved extremely useful in implementing and debugging our design, however many of its more advanced features, such as event-driven tasks, and dynamic task creation, were left unused. This is because of a lesson learned many times over the course of these three projects, that simpler is almost always better when it comes to low level programming. \n\n# References\n\n\\[1\\] M. Cheng, "Project 3", *Webhome.csc.uvic.ca*, 2019. \\[Online\\]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. \\[Accessed: Apr-2019\\].\n\n\\[2\\] "Roomba Report | Neil\'s Log Book", *Nrqm.ca*, 2019. \\[Online\\]. Available: https://nrqm.ca/roomba-report/. \\[Accessed: Apr-2019\\].\n',
        plainTxt: 'Author&#39;s Note\nThis blog post is part three in a series originally put together for the University of Victoria&#39;s CSC 460 course. The original content was publishd April 7 2019 by Torrey Randolph and myself. As that webpage no longer exists I am now hosting the content here.\nHere are links to part 1 and part 2.\n\nIntroduction\nAs our final project in CSC 460 we created a semi-autonomous, remote controlled, Roomba. This project is the culmination of the lessons we learned in Project 1, where we interfaced with many of the same pieces of hardware, and Project 2, where we developed an RTOS to assist us in this project. \nThe Project 3 Roomba has a number of features which we needed to develop in order to compete in a final tournament between teams of similarly constructed robots. Our Roombas would attempt to defend &quot;castle&quot; structures whilst also doing battle with other Roombas. To achieve this goal we needed to provide the ability to:\ndrive the Roomba using a joystick,\naim and fire a laser,\ndetect when we are shot by another Roomba&#39;s laser.\n\nIn addition to these features we also provide a couple of semi-autonomous features based off the project description [1], namely the ability to detect walls and infrared (IR) beams. These deliverables were split into two phases. A first phase focuses on the human-controlled features, as well as the Roomba&#39;s ability to respond to being hit with a laser. The second phase focuses on the semi-autonomous features.\nTo help organize, debug, and manage this project we make use of the RTOS we developed in Project 2. This RTOS is based on a Time Triggered Architecture (TTA) and, as such, our design is segmented into a series of tasks run on two Arduino boards, one attached directly to a Roomba and the second attached to a dual analog stick controller.\nSoftware Dependencies\nWe took advantage of the software ecosystems provided by companies like Atmel and Arduino, as well as community created tools and libraries. Here are the major dependencies we used.\nVS Code: Visual Studio Code offered a development experience our team was familiar with as well as helpful extensions for working with Arduino hardware.\nAVR Toolchain: In order to compile code to our board outside Arduino IDE we make use of avr-gcc, a version of the GNU Compiler Collection specifically built for AVR microcontrollers. AVR Libc is the backbone of the Arduino libraries. The defacto method of uploading and downloading software to AVR boards is AVRDUDE. We use the Arduino IDE configuration file for convenience and ease of use.\nMekpie: Our project is built using Mekpie. Mekpie is a simple C build tool written by one of our members that was updated to support building software for AVR boards. \nSaleae Logic: This is the software tool used for recording values via a Saleae USB logic analyzer. This tool is essential to collecting real-time data with little to no overhead.\n\nIn terms of code samples we also made use of Roomba code made available on Neil&#39;s Log Book [2]. This code was invaluable in our interfacing with the Roomba.\nHardware\nOur project made use of the following pieces of hardware. We combined this hardware using the usual suspects, breadboards, wires, and resistors.\nCreate 2 Programmable Roomba: The Roomba was interfaced and controlled via one of our Arduino boards.\n2x Arduino Mega 2560 boards: One board was used to directly interface with the Roomba, while the other was used to create a controller.\n2x SG-90 Micro Servos in a pan and tilt module: These two servos were used to aim a mounted laser.\n2x HC-06 Bluetooth modules: These two Bluetooth modules were used to communicate between the Roomba and the controller in phase 2.\n2x Arduino KY-023 Joystick: One analog joystick was used to control the movement of the Roomba. The second controlled the motion of the pan and tilt module. One of the joystick buttons was also hooked up to the laser.\nRobojax Red Laser: This laser was used to shoot at other Roombas.\nLight Sensor Module: This was used to detect a laser hit.\n\nPhase 1\nIn phase 1 we designed and implemented the features to control our Roomba. This mainly consisted of controlling the Roomba&#39;s movement using a joystick. Movement worked in two ways depending on the mode. In the first mode, which we called Move Mode, the Roomba can move forward, backwards, and turn on the spot, essentially free to move in whatever way the driver desires. In the second mode, which we called Still Mode, the Roomba can rotate on the spot, but cannot move forwards or backwards. The Roomba then switches between these two modes every 30 seconds as per the project specifications. This design is meant to make hitting other Roombas with a laser feasible during the tournament.\nIn addition to controlling the Roomba movement, a laser, mounted on a pan and tilt module, must also be controllable via a joystick. This will allow the Roomba to &quot;attack&quot; other Roombas by aiming its laser at their light detector. In addition, to make our Roomba &quot;killable&quot;, we needed to provide an omnidirectional light detector that &quot;kills&quot; our Roomba after two continuous seconds of a laser hit. A kill results in our Roomba no longer responding to controller input and remaining still.\nDesign\nOur design is implemented in two separate programs, one for the controller, and one for the Roomba. These two programs communicate via Bluetooth. We adapted the same messaging system as in Project 1. In this system the controller program sends the Roomba program packets containing the joystick positions and button statuses. The packet is preceded by a four byte header, which is used to synchronize the packet transmissions. New in Project 3, we introduced two-way communication by having the Roomba program send debug information back over Bluetooth. This allowed us to see debug information on a serial monitor from both programs when running. Additionally, the tracing system provided by our RTOS was usable with both programs, allowing us to easily see a trace of our tasks running, without having to plug in a logic analyzer. \nController\nFor the controller program, our design has two tasks: one for sampling inputs from the controller, and one for forwarding Bluetooth messages from the board over USB to the computer so that they could be seen on a serial monitor. Sampling input from the controller would run every 150 ms. We adjusted this value multiple times during development, but found that periods less than this did not offer much of an advantage, and produced more Bluetooth-related errors. The task that forwards Bluetooth messages had to be set to a much higher period to ensure the Bluetooth buffer did not overflow. We settled on a 30 ms period. These tasks produce the following trace:\ncontroller task trace\nIn terms of hardware, the controller would need to connect to two analog joysticks and a Bluetooth chip. The wiring design for the controller is shown below:\ncontroller block diagram\nOur design is simple from a hardware perspective, and so some sampling tasks are up to software, namely we needed to provide a low pass filter for the analog sticks in order to reduce noise, and debounce the analog stick buttons. Power for our design could come straight from a laptop as the controller could remain with the user.\nRoomba\nFor the Roomba program, our design has three tasks: one for retrieving sensor data from the Roomba, one for switching modes, and one for controlling the Roomba, servo motors, and other peripherals. The first task, retrieving sensor data, relates to phase 2, and is discussed in more detail in that section. This task would run every 120 ms. The mode switch task would run every 30 seconds, providing an easy way to reliably switch modes without having to use an extra timer. The control task would run every 60 ms, much faster than the controller&#39;s sample task. From project 1 we learned the importance of reading Bluetooth much faster than writing to it. The control task receives messages from Bluetooth, changes the Roomba&#39;s current velocity and turning radius, adjusts the pan and tilt servos, and activates/deactivates the laser. These tasks produce the following trace:\nroomba task trace\nThe hardware for the Roomba is somewhat more complex than for the controller. The Roomba program would run on an Arduino board powered by the Roomba&#39;s battery. The board connects to, and powers, a photoresistor, Bluetooth chip, and laser. Additionally, a pan and tilt servo module is powered separately using a power adapter and a second power connector from the Roomba. The power adapter was needed to turn the 16 V provided by the Roomba to the 5 V needed for the servo motors.  Finally, in order to control the Roomba, we connected to its 7-pin port which provided us, in addition to power and ground, UART serial lines and a line used to tell the Roomba what baud rate we wanted to use. The wiring design for the Roomba is shown below:\nroomba block diagram\nIn addition to the features already mentioned, our design would also have to detect a photocell laser hit that lasted two seconds, and prevent the laser from being fired for more than an accumulated ten seconds. We included functions for these features in the control task. More detail will be provided below.\nImplementation\nThe controller and Roomba program implementations are largely unique programs, each having to drive unique hardware. However, they did share RTOS and messaging code. We wrote both programs concurrently, testing features one at a time. In rare cases we would create tests that relied on only one of the programs, which simplified some difficult problems.\nController\nWhen constructing the controller, we used a combination of a cardboard base, electrical tape, and twist ties to secure our hardware components. This resulted in a relatively comfortable to use dual analog controller, pictured below:\ncontroller\nIn our design, the Bluetooth forwarding task is only used for debugging. As such, our sample task can be looked at as the main loop for our controller. In it we start by sampling the x and y values from both joysticks, and then check whether one of the stick&#39;s button has been pressed. Next we write all of this data to the Bluetooth serial port. Note that this data is wrapped in a Message struct which has an unchanging 4-byte header preceding the data. In order to provide a properly initialized Message struct we took advantage of the task&#39;s state pointer to pass in an initialized Message from our main function. The code for the sample task is shown below:\nlang:c++-readonly\nbool task_sample_fn(Task_t * task) {\n    Message_t * current_message = (Message_t *) task-&gt;state;\n    current_message-&gt;u_x   = Stick::x(stick_u);\n    current_message-&gt;u_y   = Stick::y(stick_u);\n    current_message-&gt;m_x   = Stick::x(stick_m);\n    current_message-&gt;m_y   = Stick::y(stick_m);\n    current_message-&gt;flags = Stick::sw(stick_m) ? MESSAGE_LASER : 0;\n    // send the message\n    u8 * buffer = (u8 *) current_message;\n    u16 i;\n    for (i = 0; i &lt; sizeof(Message_t); i++) {\n        bluetooth-&gt;write(buffer[i]);\n    }\n    task-&gt;state = (void *) current_message;\n    return true;\n}\nRoomba\nThe Roomba hardware components were attached directly to a raised platform on top of the Roomba. Most of these components were attached via electrical tape. A red cup was used to make the photocell omnidirectional. The final assembly is pictured below:\nroomba\nFor the Roomba code, we borrowed heavily from code and advice found on Neil&#39;s Log Book [2]. The code and explanations provided there made interfacing with the Roomba a relatively painless ordeal. \nIn terms of core functionality, we had the previously mentioned tasks for switching modes and control. For switching modes our task would toggle a boolean stored by our Roomba file as well as play a one note song to provide an audio indication to the driver that the Roomba had switched modes. Additionally, we included optional print messages for debugging over Bluetooth. The code for the mode switch task is shown below:\n```lang:c++-readonly\nbool task_mode_switch_fn(Task_t * task) {\n    if (Roomba::state == Roomba::Move_State) {\n        override_control = false;\n        Roomba::state = Roomba::Still_State;\n        Roomba::play_song(Roomba::Still_Song);\n    #ifdef PRINT_STATE\n        debug_print("Roomba::state = Still_State\\n");\n    #endif\n} else {\n    override_control = false;\n    Roomba::state = Roomba::Move_State;\n    Roomba::play_song(Roomba::Move_Song);\n    #ifdef PRINT_STATE\n        debug_print("Roomba::state = Move_State\\n");\n    #endif\n}\nreturn true;\n}\n```\nFor Roomba movement, we tried a number of designs. In the end we found that simpler was better. Roomba movement is governed by two parameters, radius and velocity. The Roomba can be thought of as always driving in a circle; to go straight one just needs to drive in a circle with a near infinite radius. By default we set radius to the maximum possible value. We then check if x is non-zero and if so we set the turn radius to the smallest possible value. This would effectively cause the Roomba to turn on a dime. If the Roomba is told to turn we provide it a base turn speed. In Still Mode this is the complete process. If we are in Move Mode, however, we check to see if the user has moved the stick farther in the y direction than the x direction. If so, we set the radius back to the maximum and scale the Roomba&#39;s velocity based on how far forward the stick is being held. The code for the Roomba movement is shown below:\n```lang:c++-readonly\ni16 radius = MAX_TURN_RADIUS;\nif (x &gt; 0) {\n    radius = 1;\n} else if (x &lt; 0) {\n    radius = -1;\n}\ni16 velocity = x == 0 ? 0 : TURN_SPEED;\nif (state == Move_State &amp;&amp; abs(y) &gt; abs(x)) {\n    radius   = MAX_TURN_RADIUS;\n    velocity = (((i32) y) * MAX_SPEED) / 127;\n    if (x != 0) {\n        if (velocity &gt; 0) {\n            velocity = clamp(velocity, TURN_SPEED, MAX_SPEED);\n        } else {\n            velocity = clamp(velocity, -MAX_SPEED, -TURN_SPEED);\n        }\n    }\n}\n```\nFor the photocell and laser we needed to keep track of time. This proved relatively simple as our RTOS provides a function for getting the current time in milliseconds. We simply tracked how long the photocell had been hit, and how long the laser had been on in two respective functions, and when they exceeded the maximum, took the appropriate action. For the laser that meant disabling further laser activations. For the photocell that meant stopping control and playing a short song to indicate that the Roomba had been &quot;killed&quot;.\nDrawbacks and Obstacles\nWe faced a number of obstacles while developing phase 1. A major problem was with our omnidirectional photocell not detecting a laser hit. We found that the light noise in the room was producing more change in our analog photocell than shining the laser on the cup was. We tried a number of fixes, including changing resistors in our voltage divider many times, trying a new photocell, and then switching to a digital photocell. The digital photocell proved much easier to work with, but suffered the same core problem that the laser simply was not producing enough light. The solution was to switch to a stronger laser. Once we realized this, detecting the laser hit became much easier.\nThe other core obstacle we faced during phase 1 was jerkiness and power issues with our servo motors. Our servos would twitch occasionally when powered, and we were unsure if this was a power issue or if our PWM signal was inconsistent. We looked at the signal using a logic analyzer and found that we did have some variation in the duty cycles sent to the servos, but were unconvinced that the variations were enough to cause the problems. The larger issue, however, was that, after about half a minute of the servos being on, our board would start to power cycle repeatedly, meaning we would lose Bluetooth connection and no longer be able to control our Roomba. We were unable to resolve this issue, and in the end went into the tournament without a working servo, instead relying on the Roomba movement to aim our laser.\nOutside of these issues we had a couple of problems due to a bug in our RTOS regarding scheduling more than two periodic tasks. This was a test case we missed during Project 2. As soon as we determined that this was the problem, it was a relatively easy fix.\nPhase 2\nPhase 2 of Project 3 was to implement simple semi-autonomous behaviours for our Roomba. This included two key behaviours: backing up when hitting a wall, and backing up when hitting an IR signal, or &quot;virtual wall&quot;. These behaviours could be achieved using sensors built-in to the Roomba, namely a front bumper and a front-mounted omnidirectional IR sensor. Overall this phase was far simpler than phase 1. However, we did have to modify our control design slightly, in that we needed to introduce a new &quot;override state&quot;. When in this state, driver control input would be ignored, and instead the semi-autonomous behaviour, in this case driving backwards, would be performed. This state change could be managed in a similar manner to how we handled timing in phase 1 for the laser and photocell.\nWe also opted to have these behaviours receive a lower precedence than the Roomba&#39;s mode, ie. if the Roomba entered Still Mode and the IR sensor was activated, the Roomba would not be allowed to backup. This was achieved by having the mode switch function always exit the override state if it was enabled and ignoring sensor input during Still Mode.\nImplementation\nWe created a new task that ran every 120 ms that polled sensor data from the Roomba. A two-state system was used; when the task was in the request state it sent four bytes over the Roomba UART connection, requesting the sensor data for the bumper and IR sensor. When the task is run again it is in the receive state, which will only read the data once two bytes have buffered in the Roomba UART connection. After this, the task switches back to the request state. The state diagram below illustrates this system.\nstate diagram\nThis state system is used to prevent the task from blocking, as the time it takes for the Roomba to respond to sensor data requests has some unwanted latency. Initially, this task was given a far longer period, which resulted in the sensor data we polled not picking up on short activations, such as a quick tap of the bumper. The implementation of the sensor reading is provided below.\nlang:c++-readonly\nvoid update() {\n    static bool waiting_for_data = false;\n    if (!waiting_for_data) {\n        roomba_serial-&gt;write(SENSORS);\n        roomba_serial-&gt;write(SENSOR_IR);\n        roomba_serial-&gt;write(SENSORS);\n        roomba_serial-&gt;write(SENSOR_BUMPER);\n        waiting_for_data = true;\n    } else if (roomba_serial-&gt;available() &gt;= 2) {\n        ir     = roomba_serial-&gt;read() ? true : false;\n        bumper = roomba_serial-&gt;read() &amp; 0b11 ? true : false;\n        waiting_for_data = false;\n    }\n}\nDrawbacks and Obstacles\nThe sensor system worked largely without problems. One issue with the state system, however, was that if Bluetooth cut out during a semi-autonomous behaviour the Roomba would continue to move backwards even after the override state had ended. A timeout on controller packets could have been used to resolve this issue, setting the Roomba speed to a reasonable default, like zero. However, we figured that if our Bluetooth cut out, we would have bigger problems than just the override state.\nA design drawback of our solution is that if our Roomba were to back into an IR beam, it would backup through it, effectively crossing any existing IR barrier. We decided this was an acceptable limitation, however there were a number of solutions we considered developing:\nConsider the Roomba&#39;s current direction and attempt to go in the opposite direction.\nRather than having the Roomba back up, simply have it turn 180 degrees to face the opposite direction.\nPrevent the Roomba from moving backwards at any time.\n\nAll of these solutions had problems, however, such as the 180 degree turn solution resulting in the Roomba getting itself trapped in a cycle of constantly rotating. This occurred during the final tournament to a couple other Roombas that implemented this solution. In the end we believe our simple solution was effective.\nTesting and the Tournament\nOur Roomba competed in a tournament that pitted it against Roombas with similar features. During the tournament, teams of two Roombas competed in a game of attack and defense. An arena was set up with two lanes, divided by an IR river, as well as two &quot;castles&quot; at one end. If shot by a laser these castles would be destroyed, resulting in a win for the attackers. One attacking Roomba and one defending Roomba was placed on each side of the river creating a 1v1 environment. Additionally, Roombas were outfitted with a &quot;shield&quot; which could be used to protect themselves and their castle, as well as using it to deflect attacks back at the enemy.\nBefore competing in the tournament we spent much of our time testing our Roomba features and gathering some metrics on its memory and CPU utilization.\nTesting Process\nDuring development we tested features one at a time. An essential part of the process was our use of debug messages. By forwarding messages over Bluetooth we could use the serial monitor to view information from either program while testing. For example. we could easily see what our sensor values were during phase 2, or what we thought we were setting our Roomba velocity and radius to during phase 1.\nThe RTOS traces were also useful for ensuring our tasks were running at the correct times and that no task was running over time. For hardware problems however, the logic analyzer still proved to be an invaluable tool.\nTournament Performance\nDuring the tournament we placed second. Being unable to use the servo to aim our laser was not a major disadvantage. The chaos of the tournament meant that only having to worry about aiming using our Roomba made the task of control simpler, and, focusing only on killing other Roombas, we did not have to worry about the angle of our laser. Using this technique we were able to score a kill in the first game.\nDuring the tournament we did experience some Bluetooth buffering problems. This caused our Roomba to begin to twitch after a minute or so. Thankfully, this problem could be fixed by resetting the controller, resulting in only a few moments without direct control. \nThe tournament itself was generally chaotic, and once Roombas were out of lasers to fire the best strategy seemed to be to try and ram the enemy Roomba into the IR river.\nOther Metrics\nWe were also able to collect data on our memory usage and CPU utilization using our RTOS. The pie charts presented here relate to our RTOS heap, not the C heap. This heap is used by our RTOS&#39;s custom allocator. Overall, memory was not much of an issue, and the main consumer of memory was our task pool, which could easily have been smaller as we only needed two tasks for the controller and three tasks for the Roomba, but had enough memory for up to sixty-four tasks. Otherwise, only a small amount of memory was used for structs that kept track of tuning parameters and state for hardware. The graphs below show the memory breakdown.\nmemory usage\nmemory usage\nAccording to our RTOS tracer our CPU utilization was extremely low, 0.6% for the controller, and 0.1% for the Roomba. These measurements are likely inaccurate due to the lack of resolution less than 1 ms. Our CPU utilization is still likely very efficient, however, as no task took more than 1 ms to run, meaning that most of our time was spent with the CPU in idle mode. These CPU metrics for both programs are shown below:\ncontroller cpu utilization\ncontroller cpu utilization\nConclusion\nProject 3 was an overall success despite our issues with the servos. All of our other features worked effectively. Our Roomba managed to perform well during the tournament and did not go overboard on CPU utilization. We learned a lot during this process and faced many setbacks during the development process. At least for us, the hardware generally proved more difficult than the software, though both had their fair share of challenges. This is likely just a matter of experience as neither of our team members have extensive experience with hardware.\nOur RTOS from Project 2 proved extremely useful in implementing and debugging our design, however many of its more advanced features, such as event-driven tasks, and dynamic task creation, were left unused. This is because of a lesson learned many times over the course of these three projects, that simpler is almost always better when it comes to low level programming. \nReferences\n[1] M. Cheng, &quot;Project 3&quot;, Webhome.csc.uvic.ca, 2019. [Online]. Available: https://webhome.csc.uvic.ca/~mcheng/460/spring.2019/p3.html. [Accessed: Apr-2019].\n[2] &quot;Roomba Report | Neil&#39;s Log Book&quot;, Nrqm.ca, 2019. [Online]. Available: https://nrqm.ca/roomba-report/. [Accessed: Apr-2019].\n',
        route: '/blog/rtos3',
        layout: '../../layouts/Blog',
        title: 'Creating an RTOS (Pt. 3)',
        subtitle: 'Using a handmade RTOS, Arduinos, and some LEDs to battle Roombas',
        blog: true,
        date: '05-19-2019',
    }),
    siteHistory: new Page({
        name: 'siteHistory',
        content: '',
        plainTxt: '',
        route: '/blog/siteHistory',
        layout: '../../layouts/Blog',
        title: 'Site History',
        subtitle: 'A look at the technologies used to build this site, and its past iteration.',
        blog: true,
        date: '05-16-2019',
    }),
    index: new Page({
        name: 'index',
        content: '',
        plainTxt: '',
        route: '/index',
        title: 'ejrbuss.net',
        layout: '../layouts/Home',
    }),
    work: new Page({
        name: 'work',
        content: '',
        plainTxt: '',
        route: '/work',
        layout: '../layouts/Work',
        title: 'Work',
        projects: [
            {
                logo: 'TypeMark',
                title: 'type-mark',
                href: 'http://ejrbuss.net/type-mark/',
                summary: 'A runtime type-checking library for JavaScript that supports complex predicates and object inerfaces. Heavily extendable by the user. Available through npm.',
            },
            {
                logo: 'Mekpie',
                title: 'Mekpie',
                href: 'https://ejrbuss.net/mekpie/',
                summary: 'An opinionated build system for small scale C projects, written and configured using Python. Available through pip.',
            },
            {
                logo: 'DndInitTracker',
                title: 'D&D Initiative Tracker',
                href: 'https://ejrbuss.net/dnd-initiative-tracker/',
                summary: 'A tool to help Dungeon Masters manage players and enemies when playing Dungeons and Dragons. Visit the site and step up your game.',
            },
            {
                logo: 'IndiGo',
                title: 'indiGO',
                href: 'https://ejrbuss.net/go',
                summary: "A webapp of the game Go made by a team of software engineering sudents at the University of Victoria. I was in charge of the front end design and am still proud of the game's persona-esque aesthetic.",
            },
            {
                logo: 'Ejrbuss',
                title: 'ejrbuss.net',
                href: '',
                summary: 'This website has gone through redevelopment a few times over the years. Read about past mistakes here.',
            },
        ],
        work: [
            {
                logo: 'UofA',
                title: 'UofA Engineering Department',
                href: '',
                summary: "I worked 8 months at the University of Alberta on two seperate coops. I got to work one-on-one with a Mechanical Engineering Professor as well as help maintain the engineering department's intranet.",
            },
            {
                logo: 'Ericsson',
                title: 'Ericsson',
                href: '',
                summary: "I worked as an iOS and web developer coop for 8 months at Ericsson's Ottawa site. I got to work on a diverse and distributed team of engineers.",
            },
        ],
    }),

};
